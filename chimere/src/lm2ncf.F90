program lm2ncdf
! versione 2.2  29/11/2012 michele 
  ! This program reads a LM-output file interpolated horizontally, 
  ! extracts the variables required by CHIMERE, and generates a netCDF file,
  ! input to diagmet
  ! new scheme to evaluate cloud liquid water
  ! for version chimere2008b
  use netcdf
  use calendar
#ifdef IFORT
  use ifport
  use ifposix
#endif

  implicit none 

#define NCERR(lnum) if(ncstat/=NF90_NOERR) call nc_err(ncstat,lnum,'lm2ncf.f90')
	
  !*****************************************************************************************
  ! Input parameters
  integer :: ids                     ! Starting date of CHIMERE simulation (YYYYMMDDHH)
  integer :: nhours                  ! Number of simulation hours
  character(len=32)  :: domain       ! CHIMERE domain
  character(len=132) :: fn_mdom      ! MM5 coordinates file, cross coordinates
  character(len=132) :: fn_mdom_dot  ! MM5 coordinates file, dot coordinates
  character(len=132) :: fn_coo       ! chimere coordinates file
  integer :: nzonal                  ! zonal dimension of the output arrays
  integer :: nmerid                  ! meridian dimension of the output arrays
  character(len=132) :: fn_mm5       ! input meteo file, MM5 binary format
  character(len=132) :: fn_out       ! Interpolated output file, netCDF format


  ! Constant netCDF attributes
  character(len=*),parameter :: title='CHIMERE SUITE'
  character(len=*),parameter :: subtitle='Interpolated Meteo file'
  character(len=*),parameter :: generator='Generated by prepMM5'
  character(len=*),parameter :: conventions=''

!
!definizionida diagmet

!  Array dimensions

      integer nxmax,nymax,nlevmax,nlaymax,nfilmax,nlands,nbio,nbiop
      parameter(nxmax=150)      ! Max number of horiz. grid points
      parameter(nymax=150)      ! Max number of horiz. grid points
      parameter(nlevmax=50)           ! Max number of native levels
      parameter(nlaymax=50)           ! Max Number of CHIMERE layers
      parameter(nfilmax=50)           ! Max number of input meteo files


!  Parameterization constants and thresholds

      real clol0,clom0,cloh0,clol2,clom2,cloh2,topl,topm,toph
      real odclw,odcic,ztherm,woff,ric
      real fcor
      real dvsca,topcldmax
      real crhx,vkmindry,vkminup,vkminwet,vkmax,rlam,pblmin,vkminur,soimdef
      real zustar
      real u10,u10s,xsea
      integer ns
      parameter(clol0=50.0)           ! Low    clouds optical depth for cl fraction=1
      parameter(clom0=10.0)           ! Medium clouds optical depth for cl fraction=1
      parameter(cloh0= 2.0)           ! High   clouds optical depth for cl fraction=1
      parameter(clol2=0.025)          ! Low    clouds optical depth /m for RH=1
      parameter(clom2=0.010)          ! Medium clouds optical depth /m for RH=1
      parameter(cloh2=0.005)          ! High   clouds optical depth /m for RH=1
      parameter(topl=2500.)           ! Low cloud top altidue AGL
      parameter(topm=6000.)           ! Medium cloud top altidue AGL
      parameter(toph=20000.)          ! High cloud top altidue AGL
      parameter(odclw=0.18e3)         ! Optical depth rate for liquid water
      parameter(odcic=0.06e3/0.9)     ! Optical depth rate for ice
      parameter(ztherm=25.0)          ! Height of thermals start
      parameter(woff=0.5)             ! Wind offset to smooth Richardson numbers (m/s)
      parameter(ric=0.5)              ! Troen & Mahrt suggestion for critical Ri for BL top
      parameter(fcor=0.0001)          ! Coriolis parameter
      parameter(dvsca=1000.0)         ! Entrain./Detrain. first guess vertical scale (m)
      parameter(crhx=0.90)            ! Min RH for cloud BLH enhancement
      parameter(vkmindry=0.1)         ! Minimum Kz in the dry boundary layer (m2/s)
      parameter(vkminwet=5.0)         ! Minimum Kz in cloudy boundary layer (m2/s)
      parameter(vkminup=0.1)          ! Minimum Kz above PBL (m2/s)
      parameter(vkmax=500.)           ! Maximum Kz
      parameter(rlam=150.)            ! Upper air mixing length
      parameter(pblmin=20.)           ! Minimum PBL height
      parameter(topcldmax=1000.)      ! Maximum cloud top for extra BL mixing due to cloud
      parameter(soimdef=1)      




      real,allocatable,dimension(:,:,:)::alti,pres,temp,mixr,zwin,mwin,cliq,cice,rain

!      real alti(nxmax,nymax,nlevmax) ! Input altitude field (m)
!      real pres(nxmax,nymax,nlevmax) ! Input pressure field (Pa)
!      real temp(nxmax,nymax,nlevmax) ! Input temperature field (K)
!      real mixr(nxmax,nymax,nlevmax) ! Input mixing ratio field (Kg/Kg)
!      real zwin(nxmax,nymax,nlevmax) ! Input zonal wind (m/s)
!      real mwin(nxmax,nymax,nlevmax) ! Input meridional wind (m/s)
!      real cliq(nxmax,nymax,nlevmax) ! Input cloud liquid water mixing ratio (Kg/Kg)
!      real cice(nxmax,nymax,nlevmax) ! Input ice liquid water mixing ratio (Kg/Kg)
!      real rain(nxmax,nymax,nlevmax) ! Input rain water mixing ratio (Kg/Kg)
      real, allocatable,dimension(:,:)::clol,clom,cloh,pblh,u10m,v10m,usta,tem2,swrd,sshf,slhf,lspc,copc,soim
!      real clol(nxmax,nymax)         ! Low cloud fraction (0-1)
!      real clom(nxmax,nymax)         ! Medium cloud fraction (0-1)
!      real cloh(nxmax,nymax)         ! High cloud fraction (0-1)
!      real pblh(nxmax,nymax)         ! mixed layer height (m)
!      real u10m(nxmax,nymax)         ! U 10m (m/s)
!      real v10m(nxmax,nymax)         ! V 10m (m/s)
!      real usta(nxmax,nymax)         ! U* (m/s)
!      real tem2(nxmax,nymax)         ! 2m temperature (K)
!      real sshf(nxmax,nymax)         ! Surface sensible heat flux (W/m2)
!      real slhf(nxmax,nymax)         ! Surface latent heat flux (W/m2)
!      real lspc(nxmax,nymax)         ! large-scale precipitation (mm/h)
!      real copc(nxmax,nymax)         ! convective precipitation (mm/h)
!      real soim(nxmax,nymax)         ! Soil Moisture (m3/m3)




      real czen
      real zchim1
      real zchim2
      real totopd,opdl,opdm,opdh,opdl1,opdm1,opdh1,opl,opm,oph
      real upm,uwc,ufx           ! Urban correcs: minimal PBL, wind correction and heat flux
 
      real tim0,tim,tim1,tlon,dec,soltim,slat
      real rich,dtheta,cdnm,cdn2,facm,fm,cd,ustar,vustar,vustas
      real ustas,z0s,cdnms,fk
      real obuk,zeta,zeta0,ra,eta,eta0,wstar,az0,awf,auf,apm
      real potts,potf,potfm,pott0,pott1,heat,humf,zh,zt
      real tstart,tlf,wlf,dt0,w20,z0,testscale,w2start,dtstart
      real beta1,beta2,vscale,sigw,sigt,zmid,buoy,dz,zii
      real pi,p,vapp,wf,uf,pm,z1,z2,x1,x2
      real qsbt,pf,zln,dt1,wstar0,poust
      real rhmaxx,topcld,topcldw
      real vkminbl,ep,zn,wc,zsl
      real dzz,ss,rig,tbar,qbar,alph,chi,dk,upkz,srig
      real crhl,crhm,crhh

      integer nlevels
      integer nlayers
      integer idstart
      integer idrefe
      integer idnow
      integer nsho
      integer levl,levm,levh
      integer iyear,imon,iday,ihour
      integer levstart
      integer id(nfilmax)

      integer iopt_flux
      integer iopt_u10m
      integer iopt_usta
      integer iopt_pblh
      integer iopt_cice
      integer iopt_rain
      integer iopt_clol
      integer iopt_clom
      integer iopt_cloh
      integer iopt_urbc
      integer iopt_soim
      integer iopt_eros
      integer iopt_resu
      integer iopt_cloudw,iopt_upblcor,iopt_cldmix

      integer iread_u10m
      integer iread_usta
      integer iread_flux
      integer iread_pblh
      integer iread_cliq
      integer iread_cice
      integer iread_rain
      integer iread_clol
      integer iread_clom
      integer iread_cloh
      integer iread_lspc
      integer iread_copc
      integer iread_soim

      integer ifn_mete
      integer ifn_bemi
      integer ifn_minf
      integer ifn_tem2
      integer ifn_swrd
      integer ifn_u10m
      integer ifn_v10m
      integer ifn_usta
      integer ifn_sshf
      integer ifn_slhf
      integer ifn_pblh
      integer ifn_cliq
      integer ifn_cice
      integer ifn_rain
      integer ifn_clol
      integer ifn_clom
      integer ifn_cloh
      integer ifn_lspc
      integer ifn_copc
      integer ifn_soim
      integer ifn_pres
      integer ifn_alti
      integer ifn_zwin
      integer ifn_mwin
      integer ifn_temp
      integer ifn_mixr
      integer ifn_coo

      integer nl,nlay,im1,n1,nb,nla,nit,i1,np,im,il

      character*132 fniU     ! 3D zonal wind (m/s)
      character*132 fniV     ! 3D meridional wind (m/s)
      character*132 fniT     ! 3D temperature (K)
      character*132 fniQ     ! 3D specific humidity (kg/kg)
      character*132 fniL     ! 3D cloud liquid water
      character*132 fniI     ! 3D cloud ice water
      character*132 fniR     ! 3D rain water
      character*132 fniA     ! 3D Altitude ag
      character*132 fniP     ! 3D Pressure
      character*132 fniU10M  ! 2D u10m file
      character*132 fniV10M  ! 2D v10m file
      character*132 fniUSTA  ! 2D u* file
      character*132 fniLOWC  ! 2D low    cloudiness (0-1)
      character*132 fniMEDC  ! 2D medium cloudiness (0-1)
      character*132 fniHIGC  ! 2D high   cloudiness
      character*132 fniTEM2  ! 2D 2m Temperature
      character*132 fniSWRD  ! 2D short wave radiation 
      character*132 fniSSHF  ! 2D surface sensible heat fluxes
      character*132 fniSLHF  ! 2D Latent heat fluxes
      character*132 fniPBLH  ! 2D Boundary Layer Height file
      character*132 fniLSPC  ! 2D Large-scale precipitation file
      character*132 fniCOPC  ! 2D Convective precipitation file
      character*132 fniSOIM  ! 2D Soil Moisture
      character*132 fniCOO   ! Coordinates file
      character*132 fniLDU   ! Landuse file
      character*132 fniLAP   ! Land parameters file
      character*132 fniBIO   ! Biogenic emissions distribution factors
      character*132 fniVCO   ! File containing the vertical hybrid coefficients
      character*132 fniMET   ! Input meteo information file

      character*132 fnoBIO   ! Biogenic emissions

      character*132 dummy

      real notzero



  ! Indexes to variables
  ! Order is not significant.
  !! CAUTION !!
  ! If you add variables, please insert them between IFIRST
  ! and ILAST.
  ! Do not insert blank lines between IFIRST and ILAST

  integer,parameter :: IFIRST = __LINE__
  integer,parameter :: IALTI1 = __LINE__ -IFIRST
  integer,parameter :: IPRES  = __LINE__ -IFIRST
  integer,parameter :: IWINZ  = __LINE__ -IFIRST
  integer,parameter :: IWINM  = __LINE__ -IFIRST
  integer,parameter :: IRMIX  = __LINE__ -IFIRST
  integer,parameter :: ITEMP  = __LINE__ -IFIRST
  integer,parameter :: IT2M   = __LINE__ -IFIRST
  integer,parameter :: ICLIQ  = __LINE__ -IFIRST
  integer,parameter :: IRICE  = __LINE__ -IFIRST
  integer,parameter :: IRAIN  = __LINE__ -IFIRST
  integer,parameter :: ILCC   = __LINE__ -IFIRST
  integer,parameter :: IMCC   = __LINE__ -IFIRST
  integer,parameter :: IHCC   = __LINE__ -IFIRST
  integer,parameter :: IU10M  = __LINE__ -IFIRST
  integer,parameter :: IV10M  = __LINE__ -IFIRST
  integer,parameter :: IUST   = __LINE__ -IFIRST
  integer,parameter :: ISSH   = __LINE__ -IFIRST
  integer,parameter :: ISLH   = __LINE__ -IFIRST
  integer,parameter :: IPBL   = __LINE__ -IFIRST
  integer,parameter :: ILSPC  = __LINE__ -IFIRST
  integer,parameter :: ICOPC  = __LINE__ -IFIRST
  integer,parameter :: ISOIM  = __LINE__ -IFIRST
  integer,parameter :: ISWD   = __LINE__ -IFIRST
  integer,parameter :: ILAST  = __LINE__ -IFIRST

  integer,parameter :: nvars= ILAST -1

  ! local constants
  integer,parameter :: dlen = 19             ! length of a date string in MM5 format

  type :: varmeta
     character(len=7)  :: mmvarname
     integer           :: dim
     character(len=4)  :: ncvarname
     character(len=9)  :: unit
     integer           :: iread 
     integer           :: varid              ! returned by nf90_def_var
     character(len=40) :: description
  end type varmeta
  type(varmeta),dimension(nvars)      :: meta

  type :: myptr
     real,dimension(:,:,:),pointer    :: ptr
  end type myptr
  type(myptr),dimension(nvars)        :: vtab
  integer :: ivar                                  ! variable selector : vtab(ivar)

  character(len=7),dimension(50)      :: vname

  !  MM5 Standard outputs (non modifiable)                                

  integer(kind=4),dimension(50,20)    :: bhi
  real(kind=4),dimension(20,20)       :: bhr
  character(len=80),dimension(50,20)  :: bhic
  character(len=80),dimension(20,20)  :: bhrc
  integer(kind=4)                     :: ndim
  integer(kind=4),dimension(4)        :: start_index,end_index
  character(len=4)                    :: staggering
  character(len=4)                    :: ordering
  character(len=24)                   :: current_date
  character(len=25)                   :: uni
  character(len=46)                   :: description


  ! Other MM5 variables
  real(kind=4) :: mm5time

  !  Indices and other stuff
  integer(kind=4) :: iflag
  integer :: i,j,k,ii,jj,kk
  integer :: klev,ime,izo
  integer :: ierr
  integer :: slot            ! time slot of the MM5 file
  integer :: irec            ! record index of the netCDF output file
  integer :: iho             ! hour of the current MM5 record

  ! netcdf stuff
  integer :: ncid
  integer :: ncstat                                ! return code for netcdf functions
  integer :: timedimid,datedimid
  integer :: wedimid
  integer :: sndimid
  integer :: btdimid                               ! dimension identifiers
  integer :: timesvarid,lonvarid,latvarid
  integer,allocatable,dimension(:) :: dimids       ! dimension vector
  integer,allocatable,dimension(:) :: stvec,cntvec ! start and count vectors for ncwrites
  integer,allocatable,dimension(:) :: bkvec        ! to backspace the netCDF file
  character(len=1024) :: history

  ! array dimensions
  integer :: nxx,nyy,nlev            ! MM5 field dimensions, non staggered

  ! misc
  integer :: bhistime         ! Starting date of MM5 file (YYYYMMDDHH)
  integer :: ide              ! Ending date of CHIMERE simulation (YYYYMMDDHH)
  integer :: idc              ! current date (YYYYMMDDHH)
  integer :: status

  ! arrays to hold data
  integer,allocatable,dimension(:)    :: ixd,iyd,ixc,iyc ! indexes from weight files
  real(kind=4),allocatable,dimension(:,:,:,:) :: data    ! Input data buffer
  real,allocatable,dimension(:)       :: wxd,wyd,wxc,wyc ! weights from weight files
  real,allocatable,dimension(:,:,:)   :: xout            ! output buffer
  real,allocatable,dimension(:,:)     :: xlon            ! longitude of chimere grid points
  real,allocatable,dimension(:,:)     :: xlat            ! latitude of chimere grid points

  ! local arrays, for intermediate computations
  real,allocatable,dimension(:,:)     :: cop0
  real,allocatable,dimension(:,:)     :: lsp0
  real,allocatable,dimension(:,:)     :: coso
  real,allocatable,dimension(:,:)     :: sino
  real,allocatable,dimension(:,:,:)   :: pref        ! Reference pressure


  ! functions
  Integer :: mm5date2numeric ! to transform MM5 time into CHIMERE time
  character(len=dlen) :: numeric2mm5date ! the reciprocal

  ! system information
  character(len=32) :: systime
  character(len=64) :: hname
  character(len=32) :: usrname
  character(len=255) :: cwd

!  File names

      
      fniU    = 'ZWIN_3D'
      fniV    = 'MWIN_3D'
      fniT    = 'TEMP_3D'
      fniQ    = 'MIXR_3D'
      fniL    = 'CLIQ_3D'
      fniI    = 'CICE_3D'
      fniR    = 'RAIN_3D'
      fniA    = 'ALTI_3D'
      fniP    = 'PRES_3D'
      fniTEM2 = 'TEM2_2D'
      fniSWRD = 'SWRD_2D'
      fniSSHF = 'SSHF_2D'
      fniSLHF = 'SLHF_2D'
      fniU10M = 'U10M_2D'
      fniV10M = 'V10M_2D'
      fniUSTA = 'USTA_2D'
      fniLOWC = 'LOWC_2D'
      fniMEDC = 'MEDC_2D'
      fniHIGC = 'HIGC_2D'
      fniPBLH = 'PBLH_2D'
      fniLSPC = 'TOPC_2D'
      fniLSPC = 'TOPC_2D'
      fniCOPC = 'COPC_2D'
      fniSOIM = 'SOIM_2D'

      vname(1)   = 'ALTI_3D'
      vname(2)   = 'PRES_3D'
      vname(3)   = 'ZWIN_3D'
      vname(4)   = 'MWIN_3D'
      vname(5)   = 'MIXR_3D'
      vname(6)   = 'TEMP_3D'
      vname(7)   = 'TEM2_2D'
      vname(8)   = 'CLIQ_3D'
      vname(9)   = 'CICE_3D'
      vname(10)  = 'RAIN_3D'
      vname(11) = 'LOWC_2D'
      vname(12) = 'MEDC_2D'
      vname(13) = 'HIGC_2D'
      vname(14) = 'U10M_2D'
      vname(15) = 'V10M_2D'
      vname(16) = 'USTA_2D'
      vname(17) = 'SSHF_2D'
      vname(18) = 'SLHF_2D'
      vname(19) = 'PBLH_2D'
      vname(20) = 'TOPC_2D'
      vname(21) = 'COPC_2D'
      vname(22) = 'SOIM_2D'
!
      fn_out  = 'METEOINP.nc'
      fniMET  = 'lm2ncf.inp'
!      

  !*****************************************************************************************
      call opfi(ifn_minf,fnimet,'f','o')
      read(ifn_minf,*)ids,nhours
      read(ifn_minf,*)nlevels
      read(ifn_minf,'(a)')fn_coo
      read(ifn_minf,*)nzonal,nmerid
      read(ifn_minf,*)iopt_u10m
      read(ifn_minf,*)iopt_usta
      read(ifn_minf,*)iopt_flux
      read(ifn_minf,*)iopt_pblh
      read(ifn_minf,*)iopt_cice
      read(ifn_minf,*)iopt_rain
      read(ifn_minf,*)iopt_clol,crhl
      read(ifn_minf,*)iopt_clom,crhm
      read(ifn_minf,*)iopt_cloh,crhh
      read(ifn_minf,*)iopt_soim
      read(ifn_minf,*)iopt_cloudw
      fn_coo=trim(fn_coo)
!  Reading meteo file infos (optional files)

      iread_u10m = 0
      iread_usta = 0
      iread_flux = 0
      iread_pblh = 0
      iread_cice = 0
      iread_rain = 0
      iread_clol = 0
      iread_clom = 0
      iread_cloh = 0
      iread_cliq= 0

      if(iopt_u10m.eq.0) iread_u10m = 1
      if(iopt_usta.eq.0) iread_usta = 1
      if(iopt_flux.eq.0) iread_flux = 1
      if(iopt_pblh.eq.0) iread_pblh = 1

      if(iopt_clol.eq.0 .or. iopt_cloudw.eq.1) iread_clol = 1
      if(iopt_clom.eq.0 .or. iopt_cloudw.eq.1) iread_clom = 1
      if(iopt_cloh.eq.0 .or. iopt_cloudw.eq.1) iread_cloh = 1
!       write(6,*)'opt',iopt_clol,iopt_cloudw
!     if(iopt_cloudw.eq.0) iread_cliq = 1
      if(iopt_cice.eq.0) iread_cice = 1
      if(iopt_rain.eq.0) iread_rain = 1
      if(iopt_soim.eq.0) iread_soim = 1

!  Mandatory conditions for the aerosol version

      iread_copc = 0
      iread_lspc = 1
      if(iopt_cloudw.eq.0) iread_cliq = 1
      if(iopt_cloudw.eq.1) iread_cliq = 0
          

!  Mandatory files

      call opfi(ifn_alti,fniA,'u','o')
      call opfi(ifn_pres,fniP,'u','o')
      call opfi(ifn_zwin,fniU,'u','o')
      call opfi(ifn_mwin,fniV,'u','o')
      call opfi(ifn_mixr,fniQ,'u','o')
      call opfi(ifn_temp,fniT,'u','o')
      call opfi(ifn_tem2,fniTEM2,'u','o')
!
      call opfi(ifn_swrd,fniSWRD,'u','o')
!
!  Optional files
      if(iread_cliq.eq.1) call opfi(ifn_cliq,fniL,'u','o')
      if(iread_cice.eq.1) call opfi(ifn_cice,fniI,'u','o')
      if(iread_rain.eq.1) call opfi(ifn_rain,fniR,'u','o')
      if(iread_clol.eq.1) call opfi(ifn_clol,fniLOWC,'u','o')
      if(iread_clom.eq.1) call opfi(ifn_clom,fniMEDC,'u','o')
      if(iread_cloh.eq.1) call opfi(ifn_cloh,fniHIGC,'u','o')
      if(iread_u10m.eq.1) call opfi(ifn_u10m,fniU10M,'u','o')
      if(iread_u10m.eq.1) call opfi(ifn_v10m,fniV10M,'u','o')
      if(iread_usta.eq.1) call opfi(ifn_usta,fniUSTA,'u','o')
      if(iread_flux.eq.1) call opfi(ifn_sshf,fniSSHF,'u','o')
      if(iread_flux.eq.1) call opfi(ifn_slhf,fniSLHF,'u','o')
      if(iread_pblh.eq.1) call opfi(ifn_pblh,fniPBLH,'u','o')
      if(iread_lspc.eq.1) call opfi(ifn_lspc,fniLSPC,'u','o')
      if(iread_copc.eq.1) call opfi(ifn_copc,fniCOPC,'u','o')
      if(iread_soim.eq.1) call opfi(ifn_soim,fniSOIM,'u','o')




  ! Get various system informations
  call get_infos

  ! Initalize metadata
  call initvars
! modifico i flag di lettura in metadata

    meta(8)%iread=iread_cliq
     meta(8)%iread=1
    meta(9)%iread=iread_cice
    meta(10)%iread=iread_rain
    meta(11)%iread=iread_cloh
    meta(12)%iread=iread_clom
    meta(13)%iread=iread_clol
    meta(14)%iread=iread_u10m
    meta(15)%iread=iread_u10m
    meta(16)%iread=iread_usta
    meta(17)%iread=iread_flux
    meta(18)%iread=iread_flux
    meta(19)%iread=iread_pblh
    meta(20)%iread=iread_lspc
    meta(21)%iread=iread_copc
    meta(22)%iread=iread_soim

  ! calculate end date ide
  call reldat(ids,nhours,ide)


  ! Create netCDF out file
  ncstat=nf90_create(fn_out,NF90_CLOBBER,ncid)
  NCERR(__LINE__)
!   write(6,*)fn_coo
  ! Read coordinates
      call opfi(ifn_coo,fn_coo,'f','o')
!  open(ifn_coo,file=trim(fn_coo),form='formatted',status='old', &
!       action='read',iostat=ierr)
!  if (ierr/=0) stop 'lm2ncf : error opening COORD file'
  allocate(xlon(nzonal,nmerid))
  allocate(xlat(nzonal,nmerid))
  do ime=1,nmerid
     do izo=1,nzonal
        read(ifn_coo,*,iostat=ierr)xlon(izo,ime),xlat(izo,ime)
        if (ierr/=0) stop '***  : error reading Coordinates file'
     end do
  end do
  close(ifn_coo)


   nxx=nzonal   
   nyy=nmerid
   nlev=nlevels   


allocate(alti(nzonal,nmerid,nlev),pres(nzonal,nmerid,nlev),temp(nzonal,nmerid,nlev),mixr(nzonal,nmerid,nlev))
allocate(zwin(nzonal,nmerid,nlev),mwin(nzonal,nmerid,nlev),cliq(nzonal,nmerid,nlev),cice(nzonal,nmerid,nlev))
allocate(rain(nzonal,nmerid,nlev))

allocate(clol(nzonal,nmerid),clom(nzonal,nmerid),cloh(nzonal,nmerid),pblh(nzonal,nmerid),u10m(nzonal,nmerid))
allocate(v10m(nzonal,nmerid),usta(nzonal,nmerid),tem2(nzonal,nmerid),sshf(nzonal,nmerid),slhf(nzonal,nmerid))
allocate (lspc(nzonal,nmerid),copc(nzonal,nmerid),soim(nzonal,nmerid),swrd(nzonal,nmerid))


  

  ! define dimensions in the netCDF file, according to CHIMERE
  ! convention : X<=> i, Y<=> j
  call ncdefdim

  ! Create global attributes
  call ncdefatt

  ! define variables and allocate memory to hold them
  call def_alloc_vars

  ! leave netCDF define mode
  ncstat=nf90_enddef(ncid)
  NCERR(__LINE__)

  ! Entering data mode

  ! Writing lon,lat variables
  ncstat=nf90_put_var(ncid,lonvarid,xlon)
  NCERR(__LINE__)
  ncstat=nf90_put_var(ncid,latvarid,xlat)
  NCERR(__LINE__)

               cliq = 0.
               rain = 0.
               cice = 0.
            soim = soimdef

  ierr=0
  irec=1        ! netCDF record index
  idc=ide    ! current MM5 record date. Initialized to start the loop.
  slot=1        ! MM5 time index
!  do while ((ierr==0) .and.(idc<=ide))
   do n1=1,nhours+1
!legge i files


!  Date

         call reldat(ids,n1-1,idnow)
         call ddate(idnow,iyear,imon,iday,ihour)
         do i1=1,nfilmax
            id(i1) = idnow
         enddo
!      write(6,*)'nversione ',ids,n1,idnow,iread_clol
!  Reading Mandatory data

         read(ifn_alti)id(1),(((alti(izo,ime,nl),izo=1,nzonal),ime=1,nmerid),nl=1,nlevels)
         read(ifn_pres)id(2),(((pres(izo,ime,nl),izo=1,nzonal),ime=1,nmerid),nl=1,nlevels)
         read(ifn_zwin)id(3),(((zwin(izo,ime,nl),izo=1,nzonal),ime=1,nmerid),nl=1,nlevels)
         read(ifn_mwin)id(4),(((mwin(izo,ime,nl),izo=1,nzonal),ime=1,nmerid),nl=1,nlevels)
         read(ifn_mixr)id(5),(((mixr(izo,ime,nl),izo=1,nzonal),ime=1,nmerid),nl=1,nlevels)
         read(ifn_temp)id(6),(((temp(izo,ime,nl),izo=1,nzonal),ime=1,nmerid),nl=1,nlevels)
         read(ifn_tem2)id(7),((tem2(izo,ime),izo=1,nzonal),ime=1,nmerid)
         read(ifn_swrd)id(23),((swrd(izo,ime),izo=1,nzonal),ime=1,nmerid)
        where (swrd<0) swrd=0
!  Reading optional data
         if(iread_cice.eq.1) read(ifn_cice)id(9),(((cice(izo,ime,nl),izo=1,nzonal),ime=1,nmerid),nl=1,nlevels)
         if(iread_rain.eq.1) read(ifn_rain)id(10),(((rain(izo,ime,nl),izo=1,nzonal),ime=1,nmerid),nl=1,nlevels)
         if(iread_clol.eq.1) then
!            write(6,*)'leggio clouds'
         read(ifn_clol)id(11),((clol(izo,ime),izo=1,nzonal),ime=1,nmerid)
         end if
           if(iread_clom.eq.1) read(ifn_clom)id(12),((clom(izo,ime),izo=1,nzonal),ime=1,nmerid)
         if(iread_cloh.eq.1) read(ifn_cloh)id(13),((cloh(izo,ime),izo=1,nzonal),ime=1,nmerid)
         if(iread_u10m.eq.1) read(ifn_u10m)id(14),((u10m(izo,ime),izo=1,nzonal),ime=1,nmerid)
         if(iread_u10m.eq.1) read(ifn_v10m)id(15),((v10m(izo,ime),izo=1,nzonal),ime=1,nmerid)
!cenr3
         if(iread_usta.eq.1) read(ifn_usta)id(16),((usta(izo,ime),izo=1,nzonal),ime=1,nmerid)
         if(iread_flux.eq.1) read(ifn_sshf)id(17),((sshf(izo,ime),izo=1,nzonal),ime=1,nmerid)
         if(iread_flux.eq.1) read(ifn_slhf)id(18),((slhf(izo,ime),izo=1,nzonal),ime=1,nmerid)
         if(iread_pblh.eq.1) read(ifn_pblh)id(19),((pblh(izo,ime),izo=1,nzonal),ime=1,nmerid)
         if(iread_lspc.eq.1) read(ifn_lspc)id(20),((lspc(izo,ime),izo=1,nzonal),ime=1,nmerid)
         if(iread_copc.eq.1) read(ifn_copc)id(21),((copc(izo,ime),izo=1,nzonal),ime=1,nmerid)
         if(iread_soim.eq.1) read(ifn_soim)id(22),((soim(izo,ime),izo=1,nzonal),ime=1,nmerid)

         if(iopt_cloudw.eq.0) then
          if(n1==1) write(6,*)'read cliq from LM'
           read(ifn_cliq)id(8),(((cliq(izo,ime,nl),izo=1,nzonal),ime=1,nmerid),nl=1,nlevels)
        where (cliq<0) cliq=0
          else 
!          write(6,*)'input cloud' 
!          do izo=1,nzonal
!          do ime=1,nmerid
!           write(6,*)izo,ime,clol(izo,ime),clom(izo,ime),cloh(izo,ime)
!           end do
!           end do
          if(n1==1) write(6,*)'calcola cliq new scheme '
          call cloudw
         end if

!  Date check
         do i1=1,nfilmax
            if(id(i1).ne.idnow) then
              print *,'*** Date Problem with Meteo File: ',i1
              print *,'*** Expected date: ',idnow,' File date: ',id(i1)
            stop
               else
              print *,'*** Expected date: ',idnow,' File date: ',id(i1)
            endif
         enddo
         current_date=numeric2mm5date(idnow)

        if ((idc>=ids).and.(idc<=ide)) then
!           write(6,*) 'write date to netCDF file'
           ncstat=nf90_put_var(ncid,timesvarid,current_date(1:dlen), &
                start =(/1 ,   irec/), &
                count =(/dlen, 1   /))
           NCERR(__LINE__)

           ! write the result to the netCDF file.
           call write_data
! --------------------------------------------------------


           irec=irec+1
!           write(6,*)irec
        end if !((idc>=ids).and.(idc<=ide))

        slot=slot+1

  end do !(fine time ))

  if (idc<ide) then
     print *,'*** ERROR: CHIMERE Simulation period exceeding MM5 file'
     print *,'*** The CHIMERE simulation period must be contained'
     print *,'*** within one MM5 output file'
     print *,idc, ide
     stop
  end if

!  call dealloc_vars

  ncstat=nf90_close(ncid)
  NCERR(__LINE__)


contains
       subroutine cloudw

!-----------------------------------------------------------------------
! Subroutine to evaluate cloud water mixing ratio from high, medium and
! low cloud cover.
!                                             Version 1.0, SJ 13/06/2005
!                                             Version 1.0, MS 14/07/2008
!-----------------------------------------------------------------------
      implicit none
!  Parameterization constants and thresholds
      real,parameter::R=287.               ! R constant
      real,parameter::topl=2500.               ! R constant
      real,parameter::topm=6000.               ! R constant
      real,parameter::toph=20000.               ! R constant

!  Input
      integer izo,ime,nl
!      real crhl,crhm,crhh
      integer levl(nzonal,nmerid),levm(nzonal,nmerid),levh(nzonal,nmerid)


! Internal variables
 

      real n(nzonal,nmerid)
      integer Hbase_val(nzonal,nmerid)
      integer Htop_val(nzonal,nmerid)
      integer j
       real vapp,qsbt
      real,allocatable::sat(:,:,:),relhum(:,:,:),crit(:,:,:)
      integer,allocatable:: Htop(:,:,:), Hbase(:,:,:) ! Model level corresponding to cloud base



      allocate(sat(nzonal,nmerid,nlevels),relhum(nzonal,nmerid,nlevels),crit(nzonal,nmerid,nlevels))
      allocate(HTOP(nzonal,nmerid,nlevels),hbase(nzonal,nmerid,nlevels))

         write(6,*)'sono a clouds',nmerid,izo,ime
! determination of levels just below separation altitudes
        do ime=1,nmerid
        do izo=1,nzonal
     do nl=1,nlevels-1
     if(alti(izo,ime,nl).lt.topl .and. alti(izo,ime,nl+1).ge.topl) levl(izo,ime) = nl
     if(alti(izo,ime,nl).lt.topm .and. alti(izo,ime,nl+1).ge.topm) levm(izo,ime) = nl
     if(alti(izo,ime,nl).lt.toph .and. alti(izo,ime,nl+1).ge.toph) levh(izo,ime) = nl
             enddo
             enddo
             enddo

        do ime=1,nmerid
        do izo=1,nzonal
             if(alti(izo,ime,nlevels).lt.topl) levl(izo,ime) = nlevels
             if(alti(izo,ime,nlevels).lt.topm) levm(izo,ime) = nlevels
             if(alti(izo,ime,nlevels).lt.toph) levh(izo,ime) = nlevels
        end do
        end do
!            print *,'cloud level height 1',levl(np),levm(np),levh(np)
!          print *,'cloud level height 2',topl,topm,toph

        do ime=1,nmerid
        do izo=1,nzonal
           do nl=1,nlevels  
         vapp = 611.*exp(17.27*(temp(izo,ime,nl)-273.15)/(temp(izo,ime,nl)-35.86))
         qsbt = 0.622*vapp/(pres(izo,ime,nl)-vapp)
         sat(izo,ime,nl)=7.223*(1E-3*vapp)*(mixr(izo,ime,nl)/qsbt)&
          *(300/temp(izo,ime,nl))*1E-3/(pres(izo,ime,nl)/(R*temp(izo,ime,nl)))
         relhum(izo,ime,nl)=mixr(izo,ime,nl)/qsbt
         enddo
         enddo
         enddo


        do ime=1,nmerid
        do izo=1,nzonal
             do nl=1,nlevels-1

             if (nl.eq.1) then
             n(izo,ime)=1
             endif
      

             if (alti(izo,ime,nl).ge.alti(izo,ime,1).and. alti(izo,ime,nl).le.alti(izo,ime,levl(izo,ime))) then
              crit(izo,ime,nl)=crhl
!           print *,'low cloud ',crit(izo,ime,nl),crhl
            endif


           if (levm(izo,ime).le.nlevels.and.levm(izo,ime).gt.levl(izo,ime)+1) then
             if (alti(izo,ime,nl).ge.alti(izo,ime,levl(izo,ime)+1).and.alti(izo,ime,nl).le.alti(izo,ime,levm(izo,ime))) then
             crit(izo,ime,nl)=crhm
!            print *,'medium cloud',crit(izo,ime,nl),crhm 
             endif
            endif


           if (levh(izo,ime).le.nlevels.and.levh(izo,ime).gt.levm(izo,ime)+1) then
             if (alti(izo,ime,nl).ge.alti(izo,ime,levm(izo,ime)+1).and.alti(izo,ime,nl).le.alti(izo,ime,levh(izo,ime))) then
              crit(izo,ime,nl)=crhh
!             print *,'high cloud',crit(izo,ime,nl)
             endif
          endif


         if ((relhum(izo,ime,nl)).ge.crit(izo,ime,nl)) then

        if (sat(izo,ime,nl)-sat(izo,ime,nl+1).gt.0) then
        
         if (n(izo,ime).eq.1) then
          Hbase_val(izo,ime)=nl
          Hbase(izo,ime,nl)=Hbase_val(izo,ime)
          Htop_val(izo,ime)=nl
          Htop(izo,ime,nl)=Htop_val(izo,ime)
         
        else

          Htop_val(izo,ime)=nl 
          Hbase(izo,ime,nl)=Hbase_val(izo,ime)
          if (Htop_val(izo,ime).eq.nlevels-1.and.relhum(izo,ime,nlevels).ge.crit(izo,ime,nl)) then
           Htop_val(izo,ime)=nlevels
         else
           Hbase(izo,ime,nlevels)=0
           Htop(izo,ime,nlevels)=0
         endif
 
 
        do j=Hbase_val(izo,ime),Htop_val(izo,ime)
            Htop(izo,ime,j)=Htop_val(izo,ime)
            Hbase(izo,ime,j)=Hbase_val(izo,ime)
         enddo         
        endif
       
         n(izo,ime)=n(izo,ime)+1
! sat
        endif
! sat
        endif

           if ((relhum(izo,ime,nl)).lt.crit(izo,ime,nl).or.(sat(izo,ime,nl)-sat(izo,ime,nl+1).lt.0)) then
        Hbase(izo,ime,nl)=0
        Htop(izo,ime,nl)=0
        n(izo,ime)=1
         endif

! endif di rh.gt.0.75
         
          if (Hbase(izo,ime,nl).eq.Htop(izo,ime,nl)) then
          Htop(izo,ime,nl)=0
          Hbase(izo,ime,nl)=0
          endif
         
! Htop < Hbase
          if (Htop(izo,ime,nl).lt.Hbase(izo,ime,nl)) then
         print *, ' Error: Htop< Hbase', Hbase(izo,ime,nl),Htop(izo,ime,nl)
          Htop(izo,ime,nl)=0
          Hbase(izo,ime,nl)=0
          endif         
         enddo
         end do
         end do

! CALCULARE AQUA LIQUIDA NELLA NUOVELE
         do izo=1,nzonal
         do ime=1,nmerid
         do nl=1,nlevels

         if (Htop(izo,ime,nl).eq.0) then
               Hbase(izo,ime,nl)=0
         endif


! LOW CLOUD
     if (alti(izo,ime,nl).ge.alti(izo,ime,1).and.alti(izo,ime,nl).le.alti(izo,ime,levl(izo,ime)))  then
          if (Hbase(izo,ime,nl).eq.Htop(izo,ime,nl)) then
!          print *, 'Htop=Hbase !',Htop(np,nl),Hbase(np,nl)
          Htop(izo,ime,nl)=0
          Hbase(izo,ime,nl)=0
          endif

        if (Hbase(izo,ime,nl).gt.0.and.clol(izo,ime).gt.1E-10) then

         cliq(izo,ime,nl)=0.01*clol(izo,ime)*0.4*(sat(izo,ime,Hbase(izo,ime,nl))&
      -sat(izo,ime,Htop(izo,ime,nl)))*(alti(izo,ime,nl)-alti(izo,ime,Hbase(izo,ime,nl)))&
        /(alti(izo,ime,Htop(izo,ime,nl))-alti(izo,ime,Hbase(izo,ime,nl)))
                   

! if hbase etc
          else 
          cliq(izo,ime,nl)=0
          endif
          
         endif

! end LOW CLOUD


! MEDIUM CLOUD

         if (levl(izo,ime).le.nlevels.and.levm(izo,ime).gt.levl(izo,ime)+1) then

           if (alti(izo,ime,nl).ge.alti(izo,ime,levl(izo,ime)+1).and.alti(izo,ime,nl).le.alti(izo,ime,levm(izo,ime))) then

          if (Hbase(izo,ime,nl).eq.Htop(izo,ime,nl)) then
!          print *, 'Htop=Hbase !',Htop(np,nl),Hbase(np,nl)
          Htop(izo,ime,nl)=0
          Hbase(izo,ime,nl)=0
          endif

        if (Hbase(izo,ime,nl).gt.0.and.clom(izo,ime).gt.1E-10) then

         cliq(izo,ime,nl)=0.01*clol(izo,ime)*0.4&
          *(sat(izo,ime,Hbase(izo,ime,nl))-sat(izo,ime,Htop(izo,ime,nl)))&
         *(alti(izo,ime,nl)-alti(izo,ime,Hbase(izo,ime,nl)))&
           /(alti(izo,ime,Htop(izo,ime,nl))-alti(izo,ime,Hbase(izo,ime,nl)))
                   
! if hbase etc
          else 
          cliq(izo,ime,nl)=0
          endif
         endif
       endif

! end MEDIUM CLOUD

! HIGH CLOUD

         if (levm(izo,ime).le.nlevels.and.levh(izo,ime).gt.levm(izo,ime)+1) then
           if (alti(izo,ime,nl).ge.alti(izo,ime,levm(izo,ime)+1).and.alti(izo,ime,nl).le.alti(izo,ime,levh(izo,ime))) then

          if (Hbase(izo,ime,nl).eq.Htop(izo,ime,nl)) then
!          print *, 'Htop=Hbase !',Htop(np,nl),Hbase(np,nl)
          Htop(izo,ime,nl)=0
          Hbase(izo,ime,nl)=0
          endif

        if (Hbase(izo,ime,nl).gt.0.and.cloh(izo,ime).gt.1E-10) then

         cliq(izo,ime,nl)=0.01*clol(izo,ime)*0.4*&
           (sat(izo,ime,Hbase(izo,ime,nl))-sat(izo,ime,Htop(izo,ime,nl)))&
          *(alti(izo,ime,nl)-alti(izo,ime,Hbase(izo,ime,nl)))&
           /(alti(izo,ime,Htop(izo,ime,nl))-alti(izo,ime,Hbase(izo,ime,nl)))
                   
! if hbase etc
          else 
          cliq(izo,ime,nl)=0
          endif       
         endif

        endif

! end HIGH CLOUD


! CHECK valore cliq
        if (cliq(izo,ime,nl).lt.0) then          

         cliq(izo,ime,nl)=0
         endif

        if (cliq(izo,ime,nl).gt.0) then          
!         write(89,*)izo,ime,nl,crit(izo,ime,nl),cliq(izo,ime,nl),Hbase(izo,ime,nl),Htop(izo,ime,nl)&
!,clol(izo,ime),alti(izo,ime,Hbase(izo,ime,nl)),alti(izo,ime,Htop(izo,ime,nl))
         endif




         enddo
         end do
         end do

! C=0.1-0.75: scelto 0.4
! sat: water vapour saturation density slobin
! levh1: Hbase nuovele alto, levm1: nuovele media: levl1: nuovele basso
! al(nl)= altezza livello
! formula per es derivata di rh
! levh1= livello base della nuovele     
!      cliq slobin = in g/m3
!      cliq chimere in kg/kg: rho layer = (1/ro)*g/m3
!      LWC (=wc=cliq) in g/m3 o g/kg: 
!      devi cambiare g/m3 in kg/kg: fact=1E-3/1.29
!      RH in %, RH=100*rh
!      te in K
! inserire dati per determinare cloud base and top
! base/top low cloud
!         if (nl.le.levh1)
! clol etc LOWC_2D: fraction in % -> dividere per 100
! if rh>75
!         if ((0.5*((mixr(np,nl)/qsbt)+(mixr(np,nl-1)/qsbt))
!     $                       -crhh).gt.0.and.cloh(np).gt.1E-10) then


       end subroutine cloudw

  !*****************************************************************************************
  subroutine ncdefdim
    implicit none
    ncstat=nf90_def_dim(ncid,'Time',            NF90_UNLIMITED,timedimid)
    NCERR(__LINE__)
    ncstat=nf90_def_dim(ncid,'DateStrLen',      dlen,          datedimid)
    NCERR(__LINE__)
    ncstat=nf90_def_dim(ncid,'west_east',       nzonal,          wedimid)
    NCERR(__LINE__)
    ncstat=nf90_def_dim(ncid,'south_north',     nmerid,          sndimid)
    NCERR(__LINE__)
    ncstat=nf90_def_dim(ncid,'bottom_top',      nlev,            btdimid)
    NCERR(__LINE__)
  end subroutine ncdefdim

  !*****************************************************************************************
  subroutine ncdefatt
    implicit none

    ! Create global attributes
    ncstat=nf90_put_att(ncid,NF90_GLOBAL,'Title',title)
    NCERR(__LINE__)
    ncstat=nf90_put_att(ncid,NF90_GLOBAL,'Sub-title',subtitle)
    NCERR(__LINE__)
    ncstat=nf90_put_att(ncid,NF90_GLOBAL,'Generating_process',generator)
    NCERR(__LINE__)
    ncstat=nf90_put_att(ncid,NF90_GLOBAL,'Conventions',conventions)
    NCERR(__LINE__)
    ncstat=nf90_put_att(ncid,NF90_GLOBAL,'Domain',domain)
    NCERR(__LINE__)
#ifdef IFORT

    history='File '//fn_out(1:len_trim(fn_out))      // &
         ' was generated on '                        // &
         systime(1:len_trim(systime))                // &
         ' by '                                      // &
         usrname(1:len_trim(usrname))                // &
         ' on '                                      // &
         hname(1:len_trim(hname))                    // &
         ' from input file '                         // &
         fn_mm5(1:len_trim(fn_mm5))                  //'\n'C

#elif (defined(G95)+defined(PGI))

    history='File '//fn_out(1:len_trim(fn_out))      // &
         ' was generated on '                        // &
         systime(1:len_trim(systime))                // &
         ' by '                                      // &
         usrname(1:len_trim(usrname))                // &
         ' on '                                      // &
         hname(1:len_trim(hname))                    // &
         ' from input file '                         // &
         fn_mm5(1:len_trim(fn_mm5))

#else

    history='unknown'

#endif

    ncstat=nf90_put_att(ncid,NF90_GLOBAL,'history', &
         history(1:len_trim(history)))
    NCERR(__LINE__)
    ncstat=nf90_put_att(ncid,NF90_GLOBAL,'nxx'     ,nxx    )
    NCERR(__LINE__)
    ncstat=nf90_put_att(ncid,NF90_GLOBAL,'nyy'     ,nyy    )
    NCERR(__LINE__)
    ncstat=nf90_put_att(ncid,NF90_GLOBAL,'nlev'    ,nlev   )
    NCERR(__LINE__)

  end subroutine ncdefatt


  !*****************************************************************************************
  subroutine def_alloc_vars
    implicit none

    integer :: ivar

    ! Times
    ncstat=nf90_def_var(           &
         ncid,                     &
         'Times',                  &
         NF90_CHAR,                &
         (/datedimid, timedimid/), &
         timesvarid)
    NCERR(__LINE__)

    ! Longitude, latitude
    ncstat=nf90_def_var(       &
         ncid,                &
         'lon',               &
         NF90_FLOAT,          &
         (/wedimid,sndimid/), &
         lonvarid)
    NCERR(__LINE__)
    ncstat=nf90_put_att(       &
         ncid,                 &
         lonvarid,             &
         'units',              &
         'degrees_east')
    NCERR(__LINE__)
    ncstat=nf90_put_att(       &
         ncid,                 &
         lonvarid,             &
         'long_name',          &
         'Longitude')
    NCERR(__LINE__)

    ncstat=nf90_def_var(       &
         ncid,                &
         'lat',               &
         NF90_FLOAT,          &
         (/wedimid,sndimid/), &
         latvarid)
    NCERR(__LINE__)
    ncstat=nf90_put_att(       &
         ncid,                 &
         latvarid,             &
         'units',              &
         'degrees_north')
    NCERR(__LINE__)
    ncstat=nf90_put_att(       &
         ncid,                 &
         latvarid,             &
         'long_name',          &
         'Latitude')
    NCERR(__LINE__)

    ! other variables
    do ivar=1,nvars
       allocate(dimids((meta(ivar)%dim)+1))
       if (meta(ivar)%dim == 2) then              ! 2D fields
          dimids=(/wedimid,sndimid,timedimid /)
       else if  (meta(ivar)%dim == 3) then             ! 3D fields
          dimids=(/wedimid,sndimid,btdimid,timedimid /)
       else
          write(6,*) 'lm : vardefs dimension error', ivar,meta(ivar)%dim
          stop 
       end if
       ! create a netCDF variable if required
       if (meta(ivar)%iread /= 0) then
          ncstat=nf90_def_var( &
               ncid, &
               meta(ivar)%ncvarname, &
               NF90_FLOAT, &
               dimids, &
               meta(ivar)%varid)
!          write(6,*)meta(ivar)%ncvarname
          NCERR(__LINE__)
          ncstat=nf90_put_att(       &
               ncid,                 &
               meta(ivar)%varid,     &
               'units',              &
               meta(ivar)%unit)
          NCERR(__LINE__)
          ncstat=nf90_put_att(       &
               ncid,                 &
               meta(ivar)%varid,     &
               'long_name',          &
               meta(ivar)%description)
          NCERR(__LINE__)
        endif
       deallocate(dimids)
    end do !ivar=1,nvars


  end subroutine def_alloc_vars


  !*****************************************************************************************
   subroutine write_data
!(d_alti,d_pres,d_temp,d_zwin,d_mwin,d_mixr,d_tem2,&

!                 d_cliq,d_cice,d_rain,d_clol,d_clom,d_cloh,d_u10m,d_v10m,&
!                 d_usta,d_sshf,d_slhf,d_pblh,d_lspc,d_copc,d_soim)
!         
    implicit none
   integer:: ncstat
   integer,dimension(3)::stvec2d,cntvec2d
   integer,dimension(4)::stvec3d,cntvec3d
   stvec2d=(/1,1,irec/)
   stvec3d=(/1,1,1,irec/)
   cntvec2d=(/nzonal,nmerid,1/)
   cntvec3d=(/nzonal,nmerid,nlev,1/)

!     write(6,*)'nzon',nzonal,nmerid,nlev,irec
!    mandatory variable

      ncstat=nf90_put_var(ncid, meta(1)%varid,alti, (/1,1,1,irec/),(/nzonal,nmerid,nlev,1/)) 
      NCERR(__LINE__)
!          write(76,*),irec,alti
      ncstat=nf90_put_var(ncid, meta(2)%varid, pres, (/1,1,1,irec/),(/nzonal,nmerid,nlev,1/))
      NCERR(__LINE__)
      ncstat=nf90_put_var(ncid, meta(3)%varid, zwin, (/1,1,1,irec/),(/nzonal,nmerid,nlev,1/))
      NCERR(__LINE__)
      ncstat=nf90_put_var(ncid, meta(4)%varid, mwin, (/1,1,1,irec/),(/nzonal,nmerid,nlev,1/))
      NCERR(__LINE__)
      ncstat=nf90_put_var(ncid, meta(5)%varid, mixr, (/1,1,1,irec/),(/nzonal,nmerid,nlev,1/))
      NCERR(__LINE__)
      ncstat=nf90_put_var(ncid, meta(6)%varid,temp, (/1,1,1,irec/),(/nzonal,nmerid,nlev,1/))
      NCERR(__LINE__)
      ncstat=nf90_put_var(ncid, meta(7)%varid, tem2, (/1,1,irec/),(/nzonal,nmerid,1/))
      NCERR(__LINE__)
      ncstat=nf90_put_var(ncid, meta(23)%varid, swrd, (/1,1,irec/),(/nzonal,nmerid,1/))
      NCERR(__LINE__)


! optional variable
      if(meta(8)%iread==1) then
      ncstat=nf90_put_var(ncid, meta(8)%varid,cliq, (/1,1,1,irec/),(/nzonal,nmerid,nlev,1/))
      NCERR(__LINE__)
      end if
      if(meta(9)%iread==1) then
      ncstat=nf90_put_var(ncid, meta(9)%varid, cice, (/1,1,1,irec/),(/nzonal,nmerid,nlev,1/))
      NCERR(__LINE__)
      end if
      if(meta(10)%iread==1) then
      ncstat=nf90_put_var(ncid, meta(10)%varid,rain, (/1,1,1,irec/),(/nzonal,nmerid,nlev,1/))
      NCERR(__LINE__)
      end if
      if(meta(11)%iread==1) then
      ncstat=nf90_put_var(ncid, meta(11)%varid, clol, (/1,1,irec/),(/nzonal,nmerid,1/))
      NCERR(__LINE__)
      end if
      if(meta(12)%iread==1) then
      ncstat=nf90_put_var(ncid, meta(12)%varid, clom, (/1,1,irec/),(/nzonal,nmerid,1/))
      NCERR(__LINE__)
      end if
      if(meta(13)%iread==1) then
      ncstat=nf90_put_var(ncid, meta(13)%varid, cloh, (/1,1,irec/),(/nzonal,nmerid,1/))
      NCERR(__LINE__)
      end if
      if(meta(14)%iread==1) then
      ncstat=nf90_put_var(ncid, meta(14)%varid, u10m, (/1,1,irec/),(/nzonal,nmerid,1/))
      NCERR(__LINE__)
      end if
      if(meta(15)%iread==1) then
      ncstat=nf90_put_var(ncid, meta(15)%varid, v10m, (/1,1,irec/),(/nzonal,nmerid,1/))
      NCERR(__LINE__)
      end if
      if(meta(16)%iread==1) then
      ncstat=nf90_put_var(ncid, meta(16)%varid, usta, (/1,1,irec/),(/nzonal,nmerid,1/))
      NCERR(__LINE__)
      end if
      if(meta(17)%iread==1) then
      ncstat=nf90_put_var(ncid, meta(17)%varid, sshf, (/1,1,irec/),(/nzonal,nmerid,1/))
      NCERR(__LINE__)
      end if
      if(meta(18)%iread==1) then
      ncstat=nf90_put_var(ncid, meta(18)%varid, slhf, (/1,1,irec/),(/nzonal,nmerid,1/))
      NCERR(__LINE__)
      end if
      if(meta(19)%iread==1) then
      ncstat=nf90_put_var(ncid, meta(19)%varid, pblh, (/1,1,irec/),(/nzonal,nmerid,1/))
      NCERR(__LINE__)
      end if
      if(meta(20)%iread==1) then
      ncstat=nf90_put_var(ncid, meta(20)%varid, lspc, (/1,1,irec/),(/nzonal,nmerid,1/))
      NCERR(__LINE__)
      end if
      if(meta(21)%iread==1) then
      ncstat=nf90_put_var(ncid, meta(21)%varid, copc, (/1,1,irec/),(/nzonal,nmerid,1/)) 
      NCERR(__LINE__)
      end if
      if(meta(22)%iread==1) then
      ncstat=nf90_put_var(ncid, meta(22)%varid, soim, (/1,1,irec/),(/nzonal,nmerid,1/))
      NCERR(__LINE__)

      end if

   end subroutine write_data



  !*****************************************************************************************
  subroutine get_infos
    implicit none

    ! local variables
    integer :: i,j,nlen
    integer :: iutsname,ipw,myuid,pxerr,pxlen
    logical :: ziend
    ! external functions
#if defined(PGI)
    integer,external :: getcwd
    integer,external :: hostnm
#endif


#ifdef IFORT
    ! Get user name
    call pxfgetuid(myuid,pxerr)
    call pxfstructcreate('passwd',ipw,pxerr)
    call pxfgetpwuid(myuid,ipw,pxerr)
    call pxfstrget(ipw,'pw_name',usrname,pxlen,pxerr)
    nlen=len(usrname)
    do i=1,nlen
       ziend=((ichar(usrname(i:i))<ichar('A')).or.(ichar(usrname(i:i))>ichar('z')))
       if (ziend) then
          do j=i,nlen
             usrname(j:j)=' '
          end do
          exit
       end if
    end do
    ! Get current directory
    call pxfgetcwd(cwd,pxlen,pxerr)
    ! Get host name
    call pxfstructcreate('utsname',iutsname,pxerr)
    call pxfuname(iutsname,pxerr)
    call pxfstrget(iutsname,'nodename',hname,pxlen,pxerr)
    ! Get time
    systime=ctime(time())

#elif defined(G95)

    ! Get user name
    call getlog(usrname)
    nlen=len(usrname)
    do i=1,nlen
       ziend=((ichar(usrname(i:i))<ichar('A')).or.(ichar(usrname(i:i))>ichar('z')))
       if (ziend) then
          do j=i,nlen
             usrname(j:j)=' '
          end do
          exit
       end if
    end do
    ! Get current directory
    status=getcwd(cwd)
    ! Get host name
    status=hostnm(hname)
    ! Get time
    systime=ctime(time())
    call fdate(systime)

#elif defined(PGI)

    ! Get user name
    call getenv('USER',usrname)
    nlen=len(usrname)
    do i=1,nlen
       ziend=((ichar(usrname(i:i))<ichar('A')).or.(ichar(usrname(i:i))>ichar('z')))
       if (ziend) then
          do j=i,nlen
             usrname(j:j)=' '
          end do
          exit
       end if
    end do
    ! Get current directory
    status=getcwd(cwd)
    ! Get host name
    status=hostnm(hname)
    ! Get time
    !systime=ctime(time())
    call fdate(systime)

#else
    usrname='unknown'
    hname='unknown'
    systime='unknown'
    cwd='unknown'
#endif

  end subroutine get_infos

  !*****************************************************************************************
  subroutine initvars


    !  type :: varmeta
    !     character(len=7)  :: mmvarname
    !     integer           :: dim
    !     character(len=5)  :: ncvarname
    !     character(len=9)  :: unit
    !     integer           :: iread    
    !     integer           :: varid    ! returned by nf90_def_var
    !     character(len=40) :: description
    !  end type varmeta

    meta(IALTI1)=varmeta('ALTI_3D',3, 'alti'    , 'm'        ,1, 0, 'Altitude of half-sigma level'          )
    meta(IPRES) =varmeta('PRES_3D',3, 'pres'    , 'Pa'       ,1, 0, 'Pressure'                              )
    meta(IWINZ) =varmeta('ZWIN_3D',3, 'winz'    , 'm/s'      ,1, 0, 'Zonal wind'                            )
    meta(IWINM) =varmeta('MWIN_3D',3, 'winm'    , 'm/s'      ,1, 0, 'Meridional wind'                       )
    meta(IRMIX) =varmeta('MIXR_3D',3, 'sphu'    , 'kg/kg'    ,1, 0, 'Specific humidity'                     )
    meta(ITEMP) =varmeta('TEMP_3D',3, 'temp'    , 'K'        ,1, 0, 'Temperature'                           )
    meta(IT2M)  =varmeta('TEM2_2D',2, 'tem2'    , 'K'        ,1, 0, '2m air temperature'                    )
    meta(ICLIQ) =varmeta('CLIQ_3D',3, 'cliq'    , 'kg/kg'    ,1, 0, 'Cloud liquid water mixing ratio'       )
    meta(IRICE) =varmeta('CICE_3D',3, 'cice'    , 'kg/kg'    ,1, 0, 'Ice mixing ratio'                      )
    meta(IRAIN) =varmeta('RAIN_3D',3, 'rain'    , 'kg/kg'    ,1, 0, 'Rain water mixing ratio'               )
    meta(ILCC) =varmeta('LOWC_2D',2, 'clol'    , 'fraction'  ,1, 0, 'Low cloud fraction '               )
    meta(IMCC) =varmeta('MEDC_2D',2, 'clom'    , 'fraction'  ,1, 0, 'Medium cloud fraction '               )
    meta(IHCC) =varmeta('HIGC_2D',2, 'cloh'    , 'fraction'  ,1, 0, 'High  cloud fraction '               )
    meta(IU10M) =varmeta('U10M_2D',2, 'u10m'    , 'm/s'      ,1, 0, '10 m U wind'                           )
    meta(IV10M) =varmeta('V10M_2D',2, 'v10m'    , 'm/s'      ,1, 0, '10 m V wind'                           )
    meta(IUST)  =varmeta('USTA_2D',2, 'usta'    , 'm/s'      ,1, 0, 'Frictional velocity'                   )
    meta(ISSH)  =varmeta('SSHF_2D',2, 'sshf'    ,'W/m^2'     ,1, 0, 'Surface sensible heat flux'            )
    meta(ISLH)  =varmeta('SLHF_2D',2, 'slhf'    ,'W/m^2'     ,1, 0, 'Surface latent heat flux'              )
    meta(IPBL)  =varmeta('PBLH_2D',2, 'hght'    , 'm'        ,1, 0, 'PBL height from LM '                   )
    meta(ILSPC) =varmeta('TOPC_2D',2, 'lspc'    ,'kg/m^2'    ,1, 0, 'Large scale precipitation'             )
    meta(ICOPC) =varmeta('COPC_2D',2, 'copc'    ,'kg/m^2'    ,1, 0, 'convective precipitation'              )
    meta(ISOIM) =varmeta('SOIM_2D',2, 'soim'    ,'m^3/m^3'   ,1, 0, 'Soil Moisture level 1'                 )
    ! Add ShortWave Radiation for MEGAN (gc,06/02/2008)
    !'SW radiation down'                     )
    meta(ISWD)  =varmeta('SWRD_2D',2, 'swrd'    , 'W/m^2'     , 1. ,0, 'SW radiation down'                   ) 






  end subroutine initvars

!  !*****************************************************************************************
!  subroutine dealloc_vars
!
!    integer :: ivar
!
!    do ivar=1,nvars
!       deallocate (vtab(ivar)%ptr)
!    end do !ivar=1,nvars
!
!
!  end subroutine dealloc_vars
!
!  !*****************************************************************************************

END program lm2ncdf










