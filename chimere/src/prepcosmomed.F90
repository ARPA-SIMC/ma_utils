PROGRAM  prepcosmomed
!-------------------------------------------------------------------------------
! This program reads a LM-output file interpolated horizontally (GRIB), 
! extracts the variables required by CHIMERE, and generates a netCDF file,
! input to diagmet
! new scheme to evaluate cloud liquid water
! for version chimere2008b corregge alb mixr
!
! TODO (possible):
! - check the consitency of grid extremes and scanning mode in input files
! - read model grid from input file (instead of namelist)
!
!                                    Versione 3.0.2, Michele & Enrico
!                                    07/04/2017
!differenza con grib2diagmetncdf.F90   fnout  che viene gestito, prepcosmomed.inp   e USE calendar !
!modifiche Matteo per lettura psfc,cice,namelists..
!-------------------------------------------------------------------------------
USE netcdf
!USE calendar
USE grib_api
#ifdef IFORT
USE ifport
USE ifposix
#endif

IMPLICIT NONE 

#define NCERR(lnum) if(ncstat/=NF90_NOERR) call nc_err(ncstat,lnum,'grib2diagmetncdf.F90')

!-------------------------------------------------------------------------------

! Input parameters
integer :: ids                     ! Starting date of CHIMERE simulation (YYYYMMDDHH)
integer :: nhours                  ! Number of simulation hours
character(len=32)  :: domain       ! CHIMERE domain
integer :: nzonal                  ! zonal dimension of the output arrays
integer :: nmerid                  ! meridian dimension of the output arrays

! Constant netCDF attributes
character(len=*),parameter :: title='CHIMERE SUITE'
character(len=*),parameter :: subtitle='Interpolated Meteo file'
character(len=*),parameter :: generator='Generated by lm2ncf'
character(len=*),parameter :: conventions=''

!  Parameterization constants and thresholds
REAL, PARAMETER :: clol0=50.0       ! Low    clouds optical depth for cl fraction=1
REAL, PARAMETER :: clom0=10.0       ! Medium clouds optical depth for cl fraction=1
REAL, PARAMETER :: cloh0= 2.0       ! High   clouds optical depth for cl fraction=1
REAL, PARAMETER :: clol2=0.025      ! Low    clouds optical depth /m for RH=1
REAL, PARAMETER :: clom2=0.010      ! Medium clouds optical depth /m for RH=1
REAL, PARAMETER :: cloh2=0.005      ! High   clouds optical depth /m for RH=1
REAL, PARAMETER :: topl=2500.       ! Low cloud top altidue AGL
REAL, PARAMETER :: topm=6000.       ! Medium cloud top altidue AGL
REAL, PARAMETER :: toph=20000.      ! High cloud top altidue AGL
REAL, PARAMETER :: odclw=0.18e3     ! Optical depth rate for liquid water
REAL, PARAMETER :: odcic=0.06e3/0.9 ! Optical depth rate for ice
REAL, PARAMETER :: ztherm=25.0      ! Height of thermals start
REAL, PARAMETER :: woff=0.5         ! Wind offset to smooth Richardson numbers (m/s
REAL, PARAMETER :: ric=0.5          ! critical Ri for BL top (Troen & Mahrt)
REAL, PARAMETER :: fcor=0.0001      ! Coriolis parameter
REAL, PARAMETER :: dvsca=1000.0     ! Entrain./Detrain. first guess vertical scale (m)
REAL, PARAMETER :: crhx=0.90        ! Min RH for cloud BLH enhancement
REAL, PARAMETER :: vkmindry=0.1     ! Minimum Kz in the dry boundary layer (m2/s)
REAL, PARAMETER :: vkminwet=5.0     ! Minimum Kz in cloudy boundary layer (m2/s)
REAL, PARAMETER :: vkminup=0.1      ! Minimum Kz above PBL (m2/s)
REAL, PARAMETER :: vkmax=500.       ! Maximum Kz
REAL, PARAMETER :: rlam=150.        ! Upper air mixing length
REAL, PARAMETER :: pblmin=20.       ! Minimum PBL height
REAL, PARAMETER :: topcldmax=1000.  ! Max cloud top for extra BL mixing due to cloud
REAL, PARAMETER :: soimdef=1      

! Declarations for input data (files and arrays)
INTEGER, PARAMETER :: nfilmax=50    ! Max number of input meteo files
INTEGER :: ifn_alti,ifn_pres,ifn_zwin,ifn_mwin,ifn_mixr,ifn_temp
INTEGER :: ifn_tem2,ifn_swrd,ifn_alb,ifn_cliq,ifn_cice,ifn_rain,ifn_clol
INTEGER :: ifn_clom,ifn_cloh,ifn_u10m,ifn_v10m,ifn_usta,ifn_sshf,ifn_slhf
INTEGER :: ifn_pblh,ifn_lspc,ifn_copc,ifn_soim,ifn_psfc
INTEGER :: ifn_minf,ifn_coo

!INTEGER :: ig_alti=0,ig_pres=0,ig_zwin=0,ig_mwin=0,ig_mixr=0,ig_temp=0
!INTEGER :: ig_tem2=0,ig_swrd=0,ig_alb=0,ig_cliq=0,ig_cice=0,ig_rain=0,ig_clol=0
!INTEGER :: ig_clom=0,ig_cloh=0,ig_u10m=0,ig_v10m=0,ig_usta=0,ig_sshf=0,ig_slhf=0
!INTEGER :: ig_pblh=0,ig_lspc=0,ig_copc=0,ig_soim=0

! Arrays to hold data
real,allocatable,dimension(:,:)   :: xlon            ! longitude of chimere grid pts
real,allocatable,dimension(:,:)   :: xlat            ! latitude of chimere grid pts

! 3D input fields
real, allocatable, dimension(:,:,:) :: alti,pres,temp,mixr,zwin,mwin,cliq,cice,rain

! 2D input fields
real, allocatable, dimension(:,:) :: clol,clom,cloh,pblh,u10m,v10m,usta,tem2,swrd, &
  alb,sshf,slhf,lspc,copc,soim,psfc

! Identifiers of vertical levels
integer, allocatable, dimension(:,:) :: idlev

! Other variables
INTEGER :: iret(25),kf,idum,n1,i1   !!24

      real crhl,crhm,crhh

      integer nlev
      integer idnow
      integer iyear,imon,iday,ihour
      integer id(nfilmax)

      integer iopt_flux
      integer iopt_u10m
      integer iopt_usta
      integer iopt_pblh
      integer iopt_cice
      integer iopt_rain
      integer iopt_clol
      integer iopt_clom
      integer iopt_cloh
      integer iopt_soim
      integer iopt_cloudw

      integer iread_u10m
      integer iread_usta
      integer iread_flux
      integer iread_pblh
      integer iread_cliq
      integer iread_cice
      integer iread_rain
      integer iread_clol
      integer iread_clom
      integer iread_cloh
      integer iread_lspc
      integer iread_copc
      integer iread_soim

      character*132 fniU     ! 3D zonal wind (m/s)
      character*132 fniV     ! 3D meridional wind (m/s)
      character*132 fniT     ! 3D temperature (K)
      character*132 fniQ     ! 3D specific humidity (kg/kg)
      character*132 fniL     ! 3D cloud liquid water
      character*132 fniI     ! 3D cloud ice water
      character*132 fniR     ! 3D rain water
      character*132 fniA     ! 3D Altitude ag
      character*132 fniP     ! 3D Pressure
      character*132 fniU10M  ! 2D u10m file
      character*132 fniV10M  ! 2D v10m file
      character*132 fniUSTA  ! 2D u* file
      character*132 fniLOWC  ! 2D low    cloudiness (0-1)
      character*132 fniMEDC  ! 2D medium cloudiness (0-1)
      character*132 fniHIGC  ! 2D high   cloudiness
      character*132 fniTEM2  ! 2D 2m Temperature
      character*132 fniSWRD  ! 2D short wave radiation 
      character*132 fniALB   ! 2D albedo 
      character*132 fniSSHF  ! 2D surface sensible heat fluxes
      character*132 fniSLHF  ! 2D Latent heat fluxes
      character*132 fniPBLH  ! 2D Boundary Layer Height file
      character*132 fniLSPC  ! 2D Large-scale precipitation file
      character*132 fniCOPC  ! 2D Convective precipitation file
      character*132 fniSOIM  ! 2D Soil Moisture
      character*132 fniPSURF ! 2D surface pressure 

      character*132 fnicoo   ! Coordinate of grid points
      character*132 fnimet   ! Namelist file
      character*132 fnout    ! Output NetCDF data

  ! Indexes to variables
  ! Order is not significant.

  !! CAUTION !!
  ! If you add variables, please insert them between IFIRST
  ! and ILAST.
  ! Do not insert blank lines between IFIRST and ILAST

  integer,parameter :: IFIRST = __LINE__
  integer,parameter :: IALTI1 = __LINE__ -IFIRST
  integer,parameter :: IPRES  = __LINE__ -IFIRST
  integer,parameter :: IWINZ  = __LINE__ -IFIRST
  integer,parameter :: IWINM  = __LINE__ -IFIRST
  integer,parameter :: IRMIX  = __LINE__ -IFIRST
  integer,parameter :: ITEMP  = __LINE__ -IFIRST
  integer,parameter :: IT2M   = __LINE__ -IFIRST
  integer,parameter :: ICLIQ  = __LINE__ -IFIRST
  integer,parameter :: IRICE  = __LINE__ -IFIRST
  integer,parameter :: IRAIN  = __LINE__ -IFIRST
  integer,parameter :: ILCC   = __LINE__ -IFIRST
  integer,parameter :: IMCC   = __LINE__ -IFIRST
  integer,parameter :: IHCC   = __LINE__ -IFIRST
  integer,parameter :: IU10M  = __LINE__ -IFIRST
  integer,parameter :: IV10M  = __LINE__ -IFIRST
  integer,parameter :: IUST   = __LINE__ -IFIRST
  integer,parameter :: ISSH   = __LINE__ -IFIRST
  integer,parameter :: ISLH   = __LINE__ -IFIRST
  integer,parameter :: IPBL   = __LINE__ -IFIRST
  integer,parameter :: ILSPC  = __LINE__ -IFIRST
  integer,parameter :: ICOPC  = __LINE__ -IFIRST
  integer,parameter :: ISOIM  = __LINE__ -IFIRST
  integer,parameter :: ISWD   = __LINE__ -IFIRST
  integer,parameter :: IALB   = __LINE__ -IFIRST
  integer,parameter :: ISURP  = __LINE__ -IFIRST !!!
  integer,parameter :: ILAST  = __LINE__ -IFIRST

  integer,parameter :: nvars= ILAST -1

  ! local constants
  integer,parameter :: dlen = 19             ! length of a date string in MM5 format

  type :: varmeta
     character(len=7)  :: mmvarname
     integer           :: dim
     character(len=4)  :: ncvarname
     character(len=9)  :: unit
     integer           :: iread 
     integer           :: varid              ! returned by nf90_def_var
     character(len=40) :: description
  end type varmeta
  type(varmeta),dimension(nvars)      :: meta

  type :: myptr
     real,dimension(:,:,:),pointer    :: ptr
  end type myptr

  character(len=7),dimension(50)      :: vname

  !  MM5 Standard outputs (non modifiable)                                
  character(len=24)                   :: current_date

  !  Indices and other stuff
  integer :: ime,izo
  integer :: ierr
  integer :: slot            ! time slot of the MM5 file
  integer :: irec            ! record index of the netCDF output file

  ! netcdf stuff
  integer :: ncid
  integer :: ncstat                                ! return code for netcdf functions
  integer :: timedimid,datedimid
  integer :: wedimid
  integer :: sndimid
  integer :: btdimid                               ! dimension identifiers
  integer :: timesvarid,lonvarid,latvarid
  integer,allocatable,dimension(:) :: dimids       ! dimension vector
  character(len=1024) :: history

  ! array dimensions
  integer :: nxx,nyy

  ! misc
  integer :: ide              ! Ending date of CHIMERE simulation (YYYYMMDDHH)
  integer :: idc              ! current date (YYYYMMDDHH)
  integer :: status

  ! functions
! Integer :: mm5date2numeric ! to transform MM5 time into CHIMERE time
  character(len=dlen) :: numeric2mm5date ! the reciprocal

  ! system information
  character(len=32) :: systime
  character(len=64) :: hname
  character(len=32) :: usrname
  character(len=255) :: cwd

! File names
!!!fnout   = 'METEOINP.nc'
fniMET  = 'prepcosmomed.inp'

fniU    = 'ZWIN_3D.grb'
fniV    = 'MWIN_3D.grb'
fniT    = 'TEMP_3D.grb'
fniQ    = 'MIXR_3D.grb'
fniL    = 'CLIQ_3D.grb'
fniI    = 'CICE_3D.grb'
fniR    = 'RAIN_3D.grb'
fniA    = 'ALTI_3D.grb'
fniP    = 'PRES_3D.grb'
fniTEM2 = 'TEM2_2D.grb'
fniSWRD = 'SWRD_2D.grb'
fniALB  =  'ALB_2D.grb'
fniSSHF = 'SSHF_2D.grb'
fniSLHF = 'SLHF_2D.grb'
fniU10M = 'U10M_2D.grb'
fniV10M = 'V10M_2D.grb'
fniUSTA = 'USTA_2D.grb'
fniLOWC = 'LOWC_2D.grb'
fniMEDC = 'MEDC_2D.grb'
fniHIGC = 'HIGC_2D.grb'
fniPBLH = 'PBLH_2D.grb'
fniLSPC = 'TOPC_2D.grb'
fniLSPC = 'TOPC_2D.grb'
fniCOPC = 'COPC_2D.grb'
fniSOIM = 'SOIM_2D.grb'
fniPSURF = 'SURP_2D.grb' !!

! Meteorological variables names
vname(1)   = 'ALTI_3D'
vname(2)   = 'PRES_3D'
vname(3)   = 'ZWIN_3D'
vname(4)   = 'MWIN_3D'
vname(5)   = 'MIXR_3D'
vname(6)   = 'TEMP_3D'
vname(7)   = 'TEM2_2D'
vname(8)   = 'CLIQ_3D'
vname(9)   = 'CICE_3D'
vname(10)  = 'RAIN_3D'
vname(11) = 'LOWC_2D'
vname(12) = 'MEDC_2D'
vname(13) = 'HIGC_2D'
vname(14) = 'U10M_2D'
vname(15) = 'V10M_2D'
vname(16) = 'USTA_2D'
vname(17) = 'SSHF_2D'
vname(18) = 'SLHF_2D'
vname(19) = 'PBLH_2D'
vname(20) = 'TOPC_2D'
vname(21) = 'COPC_2D'
vname(22) = 'SOIM_2D'
vname(23) = 'SURP_2D'
!*******************************************************************************

! Read namelist file (grib2diagmetncdf.inp)
call opfi(ifn_minf,fnimet,'f','o')
read(ifn_minf,*)ids,nhours
read(ifn_minf,*)nlev
read(ifn_minf,'(a)')fnicoo
read(ifn_minf,*)nzonal,nmerid
read(ifn_minf,*)iopt_u10m
read(ifn_minf,*)iopt_usta
read(ifn_minf,*)iopt_flux
read(ifn_minf,*)iopt_pblh
read(ifn_minf,*)iopt_cice
read(ifn_minf,*)iopt_rain
read(ifn_minf,*)iopt_clol,crhl
read(ifn_minf,*)iopt_clom,crhm
read(ifn_minf,*)iopt_cloh,crhh
read(ifn_minf,*)iopt_soim
read(ifn_minf,*)iopt_cloudw
read(ifn_minf,'(a)')fnout
fnout=trim(fnout)
fnicoo=trim(fnicoo)

! Check which of the optional fields must be read
iread_u10m = 0
iread_usta = 0
iread_flux = 0
iread_pblh = 0
iread_cice = 0
iread_rain = 0
iread_soim = 0
iread_clol = 0
iread_clom = 0
iread_cloh = 0
iread_cliq= 0
iread_copc = 0
iread_lspc = 1

if(iopt_u10m.eq.1) iread_u10m = 1
if(iopt_usta.eq.1) iread_usta = 1
if(iopt_flux.eq.1) iread_flux = 1
if(iopt_pblh.eq.1) iread_pblh = 1
if(iopt_cice.eq.1) iread_cice = 1
if(iopt_rain.eq.1) iread_rain = 1
if(iopt_soim.eq.1) iread_soim = 1
if(iopt_clol.eq.1 .or. iopt_cloudw.eq.2) iread_clol = 1
if(iopt_clom.eq.1 .or. iopt_cloudw.eq.2) iread_clom = 1
if(iopt_cloh.eq.1 .or. iopt_cloudw.eq.2) iread_cloh = 1
if(iopt_cloudw.eq.1) iread_cliq = 1
if(iopt_cloudw.eq.2) iread_cliq = 0
! if(iopt_cloudw.eq.0) iread_cliq = 1

!  Open files for mandatory parameters
iret(:) = 0
CALL grib_open_file(ifn_alti,fniA,"r",iret(1))

CALL grib_open_file(ifn_pres,fniP,"r",iret(2))

CALL grib_open_file(ifn_zwin,fniU,"r",iret(3))
CALL grib_open_file(ifn_mwin,fniV,"r",iret(4))
CALL grib_open_file(ifn_mixr,fniQ,"r",iret(5))
CALL grib_open_file(ifn_temp,fniT,"r",iret(6))
CALL grib_open_file(ifn_tem2,fniTEM2,"r",iret(7))
CALL grib_open_file(ifn_alb,fniALB,"r",iret(8))
CALL grib_open_file(ifn_swrd,fniSWRD,"r",iret(9))
CALL grib_open_file(ifn_psfc,fniPSURF,"r",iret(10)) !!!
!  Open files for optional parameters
IF (iread_cliq == 1)  then
CALL grib_open_file(ifn_cliq,fniL,"r",iret(11))
endif

IF (iread_cice == 1) then
CALL grib_open_file(ifn_cice,fniI,"r",iret(12))
endif
IF (iread_rain == 1) then
CALL grib_open_file(ifn_rain,fniR,"r",iret(13))
endif
IF (iread_clol == 1) then
CALL grib_open_file(ifn_clol,fniLOWC,"r",iret(14))
endif
IF (iread_clom == 1) then
CALL grib_open_file(ifn_clom,fniMEDC,"r",iret(15))
endif
IF (iread_cloh == 1) then
CALL grib_open_file(ifn_cloh,fniHIGC,"r",iret(16))
endif
IF (iread_u10m == 1) then
CALL grib_open_file(ifn_u10m,fniU10M,"r",iret(17))
endif
IF (iread_u10m == 1)then
 CALL grib_open_file(ifn_v10m,fniV10M,"r",iret(18))
endif
IF (iread_usta == 1) then
CALL grib_open_file(ifn_usta,fniUSTA,"r",iret(19))
endif
IF (iread_flux == 1) then
CALL grib_open_file(ifn_sshf,fniSSHF,"r",iret(20))
endif
IF (iread_flux == 1) then
CALL grib_open_file(ifn_slhf,fniSLHF,"r",iret(21))
endif
IF (iread_pblh == 1) then
CALL grib_open_file(ifn_pblh,fniPBLH,"r",iret(22))
endif
IF (iread_lspc == 1) then
 CALL grib_open_file(ifn_lspc,fniLSPC,"r",iret(23))
endif
IF (iread_copc == 1) then
CALL grib_open_file(ifn_copc,fniCOPC,"r",iret(24))
endif
IF (iread_soim == 1) then
CALL grib_open_file(ifn_soim,fniSOIM,"r",iret(25))
endif

If (ANY(iret(:) /= 0)) GOTO 9999

! Get various system informations
call get_infos

! Initalize metadata
call initvars

! modifico i flag di lettura in metadata
meta(8)%iread=iread_cliq
meta(8)%iread=1
meta(9)%iread=iread_cice
meta(10)%iread=iread_rain
meta(11)%iread=iread_cloh
meta(12)%iread=iread_clom
meta(13)%iread=iread_clol
meta(14)%iread=iread_u10m
meta(15)%iread=iread_u10m
meta(16)%iread=iread_usta
meta(17)%iread=iread_flux
meta(18)%iread=iread_flux
meta(19)%iread=iread_pblh
meta(20)%iread=iread_lspc
meta(21)%iread=iread_copc
meta(22)%iread=iread_soim

! calculate end date ide
call reldat(ids,nhours,ide)

write(6,*) 'crea netdf'
! Create netCDF out file
ncstat=nf90_create(fnout,NF90_CLOBBER,ncid)
NCERR(__LINE__)

! Read coordinates
call opfi(ifn_coo,fnicoo,'f','o')
allocate(xlon(nzonal,nmerid))
allocate(xlat(nzonal,nmerid))
do ime=1,nmerid
   do izo=1,nzonal
      read(ifn_coo,*,iostat=ierr)xlon(izo,ime),xlat(izo,ime)
      if (ierr/=0) stop '***  : error reading Coordinates file'
   end do
end do
close(ifn_coo)

nxx=nzonal   
nyy=nmerid

! Allocate arrays to store data
ALLOCATE(alti(nzonal,nmerid,nlev),pres(nzonal,nmerid,nlev), &
         temp(nzonal,nmerid,nlev),mixr(nzonal,nmerid,nlev), &
         zwin(nzonal,nmerid,nlev),mwin(nzonal,nmerid,nlev), &
         cliq(nzonal,nmerid,nlev),cice(nzonal,nmerid,nlev), &
         rain(nzonal,nmerid,nlev))

ALLOCATE(clol(nzonal,nmerid),clom(nzonal,nmerid),cloh(nzonal,nmerid), &
         pblh(nzonal,nmerid),u10m(nzonal,nmerid),v10m(nzonal,nmerid), &
         usta(nzonal,nmerid),tem2(nzonal,nmerid),sshf(nzonal,nmerid), &
         slhf(nzonal,nmerid),lspc(nzonal,nmerid),copc(nzonal,nmerid), &
         soim(nzonal,nmerid),swrd(nzonal,nmerid),alb(nzonal,nmerid), &
         psfc(nzonal,nmerid))

ALLOCATE (idlev(10,nlev))

! define dimensions in the netCDF file, according to CHIMERE
! convention : X<=> i, Y<=> j
call ncdefdim

! Create global attributes
call ncdefatt

! define variables and allocate memory to hold them
call def_alloc_vars

! leave netCDF define mode
ncstat=nf90_enddef(ncid)
NCERR(__LINE__)

! Writing lon,lat variables
ncstat=nf90_put_var(ncid,lonvarid,xlon)
NCERR(__LINE__)
ncstat=nf90_put_var(ncid,latvarid,xlat)
NCERR(__LINE__)

cliq = 0.
rain = 0.
cice = 0.
soim = soimdef

ierr=0
irec=1        ! netCDF record index
idc=ide       ! current MM5 record date. Initialized to start the loop.
slot=1        ! MM5 time index

!-------------------------------------------------------------------------------
! Main loop (input dates)


DO n1 = 1,nhours+1
     write(6,*) 'time ', n1

  CALL reldat(ids,n1-1,idnow)
  CALL ddate(idnow,iyear,imon,iday,ihour)
  id(1:nfilmax) = idnow
! Reading Mandatory data
  CALL grib_read_3d(ifn_alti,"ALTI_3D",nzonal,nmerid,nlev,&
    id(1),idlev(1,1:nlev),alti(:,:,:))
  CALL grib_read_3d(ifn_pres,"PRES_3D",nzonal,nmerid,nlev, &
    id(2),idlev(2,1:nlev),pres(:,:,:))
  CALL grib_read_3d(ifn_zwin,"ZWIN_3D",nzonal,nmerid,nlev, &
    id(3),idlev(3,1:nlev),zwin(:,:,:))
  CALL grib_read_3d(ifn_mwin,"MWIN_3D",nzonal,nmerid,nlev, &
    id(4),idlev(4,1:nlev),mwin(:,:,:))
  CALL grib_read_3d(ifn_mixr,"MIXR_3D",nzonal,nmerid,nlev, &
    id(5),idlev(5,1:nlev),mixr(:,:,:))
  CALL grib_read_3d(ifn_temp,"TEMP_3D",nzonal,nmerid,nlev, &
    id(6),idlev(6,1:nlev),temp(:,:,:))
  
  CALL grib_read_2d(ifn_tem2,"TEM2_2D",nzonal,nmerid,id(7),idum,tem2(:,:))
  CALL grib_read_2d(ifn_swrd,"SWRD_2D",nzonal,nmerid,id(23),idum,swrd(:,:))
  CALL grib_read_2d(ifn_alb,"ALB_2D",nzonal,nmerid,id(24),idum,alb(:,:))
  CALL grib_read_2d(ifn_psfc,"SURP_2D",nzonal,nmerid,id(25),idum,psfc(:,:)) !!
! Reading optional data
  IF (iopt_cloudw==1) THEN
    CALL grib_read_3d(ifn_cliq,"CLIQ_3D",nzonal,nmerid,nlev, &
      id(8),idlev(8,1:nlev),cliq(:,:,:))
  ELSE 
    CALL cloudw
  ENDIF

  IF (iread_cice==1) &
    CALL grib_read_3d(ifn_cice,"CICE_3D",nzonal,nmerid,nlev, &
     id(9),idlev(9,1:nlev),cice(:,:,:))
  IF (iread_rain==1) &
    CALL grib_read_3d(ifn_rain,"RAIN_3D",nzonal,nmerid,nlev, &
      id(10),idlev(10,1:nlev),rain(:,:,:))

  IF (iread_clol==1) CALL grib_read_2d(ifn_clol,"CLOL_2D",nzonal,nmerid, &
    id(11),idum,clol(:,:))
  IF (iread_clom==1) CALL grib_read_2d(ifn_clom,"CLOM_2D",nzonal,nmerid, &
    id(12),idum,clom(:,:))
  IF (iread_cloh==1) CALL grib_read_2d(ifn_cloh,"CLOH_2D",nzonal,nmerid, &
    id(13),idum,cloh(:,:))
  IF (iread_u10m==1) CALL grib_read_2d(ifn_u10m,"U10M_2D",nzonal,nmerid, &
    id(14),idum,u10m(:,:))
  IF (iread_u10m==1) CALL grib_read_2d(ifn_v10m,"V10M_2D",nzonal,nmerid, &
    id(15),idum,v10m(:,:))
!
  IF (iread_usta==1) CALL grib_read_2d(ifn_usta,"USAT_2D",nzonal,nmerid, &
    id(16),idum,usta(:,:))
  IF (iread_flux==1) CALL grib_read_2d(ifn_sshf,"SSHF_2D",nzonal,nmerid, &
    id(17),idum,sshf(:,:))
  IF (iread_flux==1) CALL grib_read_2d(ifn_slhf,"SLHF_2D",nzonal,nmerid, &
    id(18),idum,slhf(:,:))
  IF (iread_pblh==1) CALL grib_read_2d(ifn_pblh,"PBLH_2D",nzonal,nmerid, &
    id(19),idum,pblh(:,:))
  IF (iread_lspc==1) CALL grib_read_2d(ifn_lspc,"LSPC_2D",nzonal,nmerid, &
    id(20),idum,lspc(:,:))
  IF (iread_copc==1) CALL grib_read_2d(ifn_copc,"COPC_2D",nzonal,nmerid, &
    id(21),idum,copc(:,:))
  IF (iread_soim==1) CALL grib_read_2d(ifn_soim,"SOIM_2D",nzonal,nmerid, &
    id(22),idum,soim(:,:))

! Check
  IF (ANY(idlev(1:6,1:nlev) /= SPREAD(idlev(1,1:nlev),DIM=1,NCOPIES=6))) then
     write(6,*) 'gen  nlev ',nlev,' idlev ',idlev
          GOTO 9998
  endif
  IF (iopt_cloudw==1 .AND. ANY(idlev(8,1:nlev) /= idlev(1,1:nlev))) then 
     write(6,*) 'clou nlev ',nlev,' idlev ',idlev
          GOTO 9998
  endif
  IF (iread_cice==1 .AND. ANY(idlev(9,1:nlev) /= idlev(1,1:nlev))) then 
     write(6,*) 'cice nlev ',nlev,' idlev ',idlev
          GOTO 9998
  endif
  IF (iread_rain==1 .AND. ANY(idlev(10,1:nlev) /= idlev(1,1:nlev)))  then 
     write(6,*) 'rain  nlev ',nlev,' idlev ',idlev
          GOTO 9998
  endif

  DO i1 = 1,nfilmax
    IF(id(i1) /= idnow) GOTO 9997
  ENDDO
  current_date=numeric2mm5date(idnow)

! Adujust values
  WHERE (mixr <= 1.e-06) mixr = 1.0e-6  !!!epsilon(mixr)
  WHERE (cliq < 0) cliq = 0.
  WHERE (swrd < 0) swrd = 0.
  swrd = 100*swrd/(100-alb)


   write(6,*)' ho letto tutto' 

! Write to NetCDF file
  IF ((idc>=ids) .AND. (idc<=ide)) THEN
    ncstat=nf90_put_var(ncid,timesvarid,current_date(1:dlen), &
      start=(/1,irec/), count=(/dlen,1/))
    NCERR(__LINE__)
   write(6,*)' scrivo tutto' 

    CALL write_data
   write(6,*)' fine  tutto' 
    irec=irec+1
  ENDIF

  slot=slot+1
ENDDO  ! main loop on dates

if (idc<ide) then
   print *,'*** ERROR: CHIMERE Simulation period exceeding COSMOMED file'
   print *,'*** The CHIMERE simulation period must be contained'
   print *,'*** within one COSMONED output file'
   print *,idc, ide
   stop
end if

ncstat=nf90_close(ncid)
NCERR(__LINE__)

STOP 0

!-------------------------------------------------------------------------------
! Fatal error handling

9999 CONTINUE
DO kf = 1,24
  IF (iret(kf) /= 0) WRITE (*,*) "Errore aprendo il file ",kf
ENDDO
STOP 1

9998 CONTINUE
WRITE (*,*) "Level problem"
STOP 4

9997 CONTINUE
print *,'*** Date Problem with Meteo File: ',i1
print *,'*** Expected date: ',idnow,' File date: ',id(i1)
STOP 5

!===============================================================================

CONTAINS

       subroutine cloudw

!-----------------------------------------------------------------------
! Subroutine to evaluate cloud water mixing ratio from high, medium and
! low cloud cover.
!                                             Version 1.0, SJ 13/06/2005
!                                             Version 1.0, MS 14/07/2008
!-----------------------------------------------------------------------
      implicit none
!  Parameterization constants and thresholds
      real,parameter::R=287.               ! R constant
      real,parameter::topl=2500.               ! R constant
      real,parameter::topm=6000.               ! R constant
      real,parameter::toph=20000.               ! R constant

!  Input
      integer izo,ime,nl
!      real crhl,crhm,crhh
      integer levl(nzonal,nmerid),levm(nzonal,nmerid),levh(nzonal,nmerid)


! Internal variables
 

      real n(nzonal,nmerid)
      integer Hbase_val(nzonal,nmerid)
      integer Htop_val(nzonal,nmerid)
      integer j
       real vapp,qsbt
      real,allocatable::sat(:,:,:),relhum(:,:,:),crit(:,:,:)
      integer,allocatable:: Htop(:,:,:), Hbase(:,:,:) ! Model level corresponding to cloud base



      allocate(sat(nzonal,nmerid,nlev),relhum(nzonal,nmerid,nlev),crit(nzonal,nmerid,nlev))
      allocate(HTOP(nzonal,nmerid,nlev),hbase(nzonal,nmerid,nlev))

! determination of levels just below separation altitudes
! ENR 30/12/2014
! Qui sembra che faccia un gran casino: 
! - i livelli in ingresso sono ordinati dall'alto, quindi nel primo ciclo la condizone non si verifica mai
! - quando tutti i livelli sono piu' in alto di topl (2500m, ad esempio con area LMSMR4 nel punto 100,195), 
!   gli array lev* sono indefiniti e il programma esplode
! segue patch (solo per farlo girare)
!print *,alti(100,195,:)
!print *,topl,topm,toph

levl(:,:) = nlev
levm(:,:) = nlev
levh(:,:) = nlev

do ime=1,nmerid
do izo=1,nzonal
do nl=1,nlev-1
  if(alti(izo,ime,nl).lt.topl .and. alti(izo,ime,nl+1).ge.topl) levl(izo,ime) = nl
  if(alti(izo,ime,nl).lt.topm .and. alti(izo,ime,nl+1).ge.topm) levm(izo,ime) = nl
  if(alti(izo,ime,nl).lt.toph .and. alti(izo,ime,nl+1).ge.toph) levh(izo,ime) = nl
enddo
enddo
enddo

do ime=1,nmerid
do izo=1,nzonal
  if(alti(izo,ime,nlev).lt.topl) levl(izo,ime) = nlev
  if(alti(izo,ime,nlev).lt.topm) levm(izo,ime) = nlev
  if(alti(izo,ime,nlev).lt.toph) levh(izo,ime) = nlev
enddo
enddo
! print *,'cloud level height 1',levl(np),levm(np),levh(np)
! print *,'cloud level height 2',topl,topm,toph

 do ime=1,nmerid
 do izo=1,nzonal
 do nl=1,nlev  
   vapp = 611.*exp(17.27*(temp(izo,ime,nl)-273.15)/(temp(izo,ime,nl)-35.86))
   qsbt = 0.622*vapp/(pres(izo,ime,nl)-vapp)
   sat(izo,ime,nl)=7.223*(1E-3*vapp)*(mixr(izo,ime,nl)/qsbt)&
      *(300/temp(izo,ime,nl))*1E-3/(pres(izo,ime,nl)/(R*temp(izo,ime,nl)))
   relhum(izo,ime,nl)=mixr(izo,ime,nl)/qsbt
 enddo
 enddo
 enddo

 do ime=1,nmerid
 do izo=1,nzonal
 do nl=1,nlev-1

   if (nl.eq.1) then
     n(izo,ime)=1
   endif

   if (alti(izo,ime,nl).ge.alti(izo,ime,1).and. alti(izo,ime,nl).le.alti(izo,ime,levl(izo,ime))) then
     crit(izo,ime,nl)=crhl
   endif

   if (levm(izo,ime).le.nlev.and.levm(izo,ime).gt.levl(izo,ime)+1) then
     if (alti(izo,ime,nl).ge.alti(izo,ime,levl(izo,ime)+1).and.alti(izo,ime,nl).le.alti(izo,ime,levm(izo,ime))) then
       crit(izo,ime,nl)=crhm
     endif
   endif

   if (levh(izo,ime).le.nlev.and.levh(izo,ime).gt.levm(izo,ime)+1) then
     if (alti(izo,ime,nl).ge.alti(izo,ime,levm(izo,ime)+1).and.alti(izo,ime,nl).le.alti(izo,ime,levh(izo,ime))) then
       crit(izo,ime,nl)=crhh
     endif
   endif

   if ((relhum(izo,ime,nl)).ge.crit(izo,ime,nl)) then
     if (sat(izo,ime,nl)-sat(izo,ime,nl+1).gt.0) then
       if (n(izo,ime).eq.1) then
         Hbase_val(izo,ime)=nl
         Hbase(izo,ime,nl)=Hbase_val(izo,ime)
         Htop_val(izo,ime)=nl
         Htop(izo,ime,nl)=Htop_val(izo,ime)
       else
         Htop_val(izo,ime)=nl 
         Hbase(izo,ime,nl)=Hbase_val(izo,ime)
         if (Htop_val(izo,ime).eq.nlev-1.and.relhum(izo,ime,nlev).ge.crit(izo,ime,nl)) then
           Htop_val(izo,ime)=nlev
         else
           Hbase(izo,ime,nlev)=0
           Htop(izo,ime,nlev)=0
         endif

         do j=Hbase_val(izo,ime),Htop_val(izo,ime)
           Htop(izo,ime,j)=Htop_val(izo,ime)
           Hbase(izo,ime,j)=Hbase_val(izo,ime)
         enddo         
       endif

       n(izo,ime)=n(izo,ime)+1
     endif
   endif

   if ((relhum(izo,ime,nl)).lt.crit(izo,ime,nl).or.(sat(izo,ime,nl)-sat(izo,ime,nl+1).lt.0)) then
     Hbase(izo,ime,nl)=0
     Htop(izo,ime,nl)=0
     n(izo,ime)=1
   endif
  
   if (Hbase(izo,ime,nl).eq.Htop(izo,ime,nl)) then
     Htop(izo,ime,nl)=0
     Hbase(izo,ime,nl)=0
   endif
         
! Htop < Hbase
   if (Htop(izo,ime,nl).lt.Hbase(izo,ime,nl)) then
     print *, ' Error: Htop< Hbase', Hbase(izo,ime,nl),Htop(izo,ime,nl)
     Htop(izo,ime,nl)=0
     Hbase(izo,ime,nl)=0
  endif         

enddo
enddo
enddo

! CALCULARE AQUA LIQUIDA NELLA NUOVELE
         do izo=1,nzonal
         do ime=1,nmerid
         do nl=1,nlev

         if (Htop(izo,ime,nl).eq.0) then
               Hbase(izo,ime,nl)=0
         endif


! LOW CLOUD
     if (alti(izo,ime,nl).ge.alti(izo,ime,1).and.alti(izo,ime,nl).le.alti(izo,ime,levl(izo,ime)))  then
          if (Hbase(izo,ime,nl).eq.Htop(izo,ime,nl)) then
!          print *, 'Htop=Hbase !',Htop(np,nl),Hbase(np,nl)
          Htop(izo,ime,nl)=0
          Hbase(izo,ime,nl)=0
          endif

        if (Hbase(izo,ime,nl).gt.0.and.clol(izo,ime).gt.1E-10) then

         cliq(izo,ime,nl)=0.01*clol(izo,ime)*0.4*(sat(izo,ime,Hbase(izo,ime,nl))&
      -sat(izo,ime,Htop(izo,ime,nl)))*(alti(izo,ime,nl)-alti(izo,ime,Hbase(izo,ime,nl)))&
        /(alti(izo,ime,Htop(izo,ime,nl))-alti(izo,ime,Hbase(izo,ime,nl)))
                   

! if hbase etc
          else 
          cliq(izo,ime,nl)=0
          endif
          
         endif

! end LOW CLOUD


! MEDIUM CLOUD

         if (levl(izo,ime).le.nlev.and.levm(izo,ime).gt.levl(izo,ime)+1) then

           if (alti(izo,ime,nl).ge.alti(izo,ime,levl(izo,ime)+1).and.alti(izo,ime,nl).le.alti(izo,ime,levm(izo,ime))) then

          if (Hbase(izo,ime,nl).eq.Htop(izo,ime,nl)) then
!          print *, 'Htop=Hbase !',Htop(np,nl),Hbase(np,nl)
          Htop(izo,ime,nl)=0
          Hbase(izo,ime,nl)=0
          endif

        if (Hbase(izo,ime,nl).gt.0.and.clom(izo,ime).gt.1E-10) then

         cliq(izo,ime,nl)=0.01*clol(izo,ime)*0.4&
          *(sat(izo,ime,Hbase(izo,ime,nl))-sat(izo,ime,Htop(izo,ime,nl)))&
         *(alti(izo,ime,nl)-alti(izo,ime,Hbase(izo,ime,nl)))&
           /(alti(izo,ime,Htop(izo,ime,nl))-alti(izo,ime,Hbase(izo,ime,nl)))
                   
! if hbase etc
          else 
          cliq(izo,ime,nl)=0
          endif
         endif
       endif

! end MEDIUM CLOUD

! HIGH CLOUD

         if (levm(izo,ime).le.nlev.and.levh(izo,ime).gt.levm(izo,ime)+1) then
           if (alti(izo,ime,nl).ge.alti(izo,ime,levm(izo,ime)+1).and.alti(izo,ime,nl).le.alti(izo,ime,levh(izo,ime))) then

          if (Hbase(izo,ime,nl).eq.Htop(izo,ime,nl)) then
!          print *, 'Htop=Hbase !',Htop(np,nl),Hbase(np,nl)
          Htop(izo,ime,nl)=0
          Hbase(izo,ime,nl)=0
          endif

        if (Hbase(izo,ime,nl).gt.0.and.cloh(izo,ime).gt.1E-10) then

         cliq(izo,ime,nl)=0.01*clol(izo,ime)*0.4*&
           (sat(izo,ime,Hbase(izo,ime,nl))-sat(izo,ime,Htop(izo,ime,nl)))&
          *(alti(izo,ime,nl)-alti(izo,ime,Hbase(izo,ime,nl)))&
           /(alti(izo,ime,Htop(izo,ime,nl))-alti(izo,ime,Hbase(izo,ime,nl)))
                   
! if hbase etc
          else 
          cliq(izo,ime,nl)=0
          endif       
         endif

        endif

! end HIGH CLOUD


! CHECK valore cliq
        if (cliq(izo,ime,nl).lt.0) then          

         cliq(izo,ime,nl)=0
         endif

        if (cliq(izo,ime,nl).gt.0) then          
!         write(89,*)izo,ime,nl,crit(izo,ime,nl),cliq(izo,ime,nl),Hbase(izo,ime,nl),Htop(izo,ime,nl)&
!,clol(izo,ime),alti(izo,ime,Hbase(izo,ime,nl)),alti(izo,ime,Htop(izo,ime,nl))
         endif




         enddo
         end do
         end do

! C=0.1-0.75: scelto 0.4
! sat: water vapour saturation density slobin
! levh1: Hbase nuovele alto, levm1: nuovele media: levl1: nuovele basso
! al(nl)= altezza livello
! formula per es derivata di rh
! levh1= livello base della nuovele     
!      cliq slobin = in g/m3
!      cliq chimere in kg/kg: rho layer = (1/ro)*g/m3
!      LWC (=wc=cliq) in g/m3 o g/kg: 
!      devi cambiare g/m3 in kg/kg: fact=1E-3/1.29
!      RH in %, RH=100*rh
!      te in K
! inserire dati per determinare cloud base and top
! base/top low cloud
!         if (nl.le.levh1)
! clol etc LOWC_2D: fraction in % -> dividere per 100
! if rh>75
!         if ((0.5*((mixr(np,nl)/qsbt)+(mixr(np,nl-1)/qsbt))
!     $                       -crhh).gt.0.and.cloh(np).gt.1E-10) then


       end subroutine cloudw

  !*****************************************************************************************
  subroutine ncdefdim
    implicit none
    ncstat=nf90_def_dim(ncid,'Time',            NF90_UNLIMITED,timedimid)
    NCERR(__LINE__)
    ncstat=nf90_def_dim(ncid,'DateStrLen',      dlen,          datedimid)
    NCERR(__LINE__)
    ncstat=nf90_def_dim(ncid,'west_east',       nzonal,          wedimid)
    NCERR(__LINE__)
    ncstat=nf90_def_dim(ncid,'south_north',     nmerid,          sndimid)
    NCERR(__LINE__)
    ncstat=nf90_def_dim(ncid,'bottom_top',      nlev,         btdimid)
    NCERR(__LINE__)
  end subroutine ncdefdim

  !*****************************************************************************************
  subroutine ncdefatt
    implicit none

    ! Create global attributes
    ncstat=nf90_put_att(ncid,NF90_GLOBAL,'Title',title)
    NCERR(__LINE__)
    ncstat=nf90_put_att(ncid,NF90_GLOBAL,'Sub-title',subtitle)
    NCERR(__LINE__)
    ncstat=nf90_put_att(ncid,NF90_GLOBAL,'Generating_process',generator)
    NCERR(__LINE__)
    ncstat=nf90_put_att(ncid,NF90_GLOBAL,'Conventions',conventions)
    NCERR(__LINE__)
    ncstat=nf90_put_att(ncid,NF90_GLOBAL,'Domain',domain)
    NCERR(__LINE__)

    history='unknown'
    ncstat=nf90_put_att(ncid,NF90_GLOBAL,'history', &
         history(1:len_trim(history)))

    NCERR(__LINE__)
    ncstat=nf90_put_att(ncid,NF90_GLOBAL,'nxx'     ,nxx    )
    NCERR(__LINE__)
    ncstat=nf90_put_att(ncid,NF90_GLOBAL,'nyy'     ,nyy    )
    NCERR(__LINE__)
    ncstat=nf90_put_att(ncid,NF90_GLOBAL,'nlev'    ,nlev   )
    NCERR(__LINE__)

  end subroutine ncdefatt


  !*****************************************************************************************
  subroutine def_alloc_vars
    implicit none

    integer :: ivar

    ! Times
    ncstat=nf90_def_var(           &
         ncid,                     &
         'Times',                  &
         NF90_CHAR,                &
         (/datedimid, timedimid/), &
         timesvarid)
    NCERR(__LINE__)

    ! Longitude, latitude
    ncstat=nf90_def_var(       &
         ncid,                &
         'lon',               &
         NF90_FLOAT,          &
         (/wedimid,sndimid/), &
         lonvarid)
    NCERR(__LINE__)
    ncstat=nf90_put_att(       &
         ncid,                 &
         lonvarid,             &
         'units',              &
         'degrees_east')
    NCERR(__LINE__)
    ncstat=nf90_put_att(       &
         ncid,                 &
         lonvarid,             &
         'long_name',          &
         'Longitude')
    NCERR(__LINE__)

    ncstat=nf90_def_var(       &
         ncid,                &
         'lat',               &
         NF90_FLOAT,          &
         (/wedimid,sndimid/), &
         latvarid)
    NCERR(__LINE__)
    ncstat=nf90_put_att(       &
         ncid,                 &
         latvarid,             &
         'units',              &
         'degrees_north')
    NCERR(__LINE__)
    ncstat=nf90_put_att(       &
         ncid,                 &
         latvarid,             &
         'long_name',          &
         'Latitude')
    NCERR(__LINE__)

    ! other variables
    do ivar=1,nvars
       allocate(dimids((meta(ivar)%dim)+1))
       if (meta(ivar)%dim == 2) then              ! 2D fields
          dimids=(/wedimid,sndimid,timedimid /)
       else if  (meta(ivar)%dim == 3) then             ! 3D fields
          dimids=(/wedimid,sndimid,btdimid,timedimid /)
       else
          write(6,*) 'lm : vardefs dimension error', ivar,meta(ivar)%dim
          stop 
       end if
       ! create a netCDF variable if required
       if (meta(ivar)%iread /= 0) then
          ncstat=nf90_def_var( &
               ncid, &
               meta(ivar)%ncvarname, &
               NF90_FLOAT, &
               dimids, &
               meta(ivar)%varid)
!          write(6,*)meta(ivar)%ncvarname
          NCERR(__LINE__)
          ncstat=nf90_put_att(       &
               ncid,                 &
               meta(ivar)%varid,     &
               'units',              &
               meta(ivar)%unit)
          NCERR(__LINE__)
          ncstat=nf90_put_att(       &
               ncid,                 &
               meta(ivar)%varid,     &
               'long_name',          &
               meta(ivar)%description)
          NCERR(__LINE__)
        endif
       deallocate(dimids)
    end do !ivar=1,nvars


  end subroutine def_alloc_vars


  !*****************************************************************************************
   subroutine write_data
!(d_alti,d_pres,d_temp,d_zwin,d_mwin,d_mixr,d_tem2,&

!                 d_cliq,d_cice,d_rain,d_clol,d_clom,d_cloh,d_u10m,d_v10m,&
!                 d_usta,d_sshf,d_slhf,d_pblh,d_lspc,d_copc,d_soim)
!         
    implicit none
   integer:: ncstat
   integer,dimension(3)::stvec2d,cntvec2d
   integer,dimension(4)::stvec3d,cntvec3d
   stvec2d=(/1,1,irec/)
   stvec3d=(/1,1,1,irec/)
   cntvec2d=(/nzonal,nmerid,1/)
   cntvec3d=(/nzonal,nmerid,nlev,1/)

!    mandatory variable

      ncstat=nf90_put_var(ncid, meta(1)%varid,alti, (/1,1,1,irec/),(/nzonal,nmerid,nlev,1/)) 
      NCERR(__LINE__)
      ncstat=nf90_put_var(ncid, meta(2)%varid, pres, (/1,1,1,irec/),(/nzonal,nmerid,nlev,1/))
      NCERR(__LINE__)
      ncstat=nf90_put_var(ncid, meta(3)%varid, zwin, (/1,1,1,irec/),(/nzonal,nmerid,nlev,1/))
      NCERR(__LINE__)
      ncstat=nf90_put_var(ncid, meta(4)%varid, mwin, (/1,1,1,irec/),(/nzonal,nmerid,nlev,1/))
      NCERR(__LINE__)
      ncstat=nf90_put_var(ncid, meta(5)%varid, mixr, (/1,1,1,irec/),(/nzonal,nmerid,nlev,1/))
      NCERR(__LINE__)
      ncstat=nf90_put_var(ncid, meta(6)%varid,temp, (/1,1,1,irec/),(/nzonal,nmerid,nlev,1/))
      NCERR(__LINE__)
      ncstat=nf90_put_var(ncid, meta(7)%varid, tem2, (/1,1,irec/),(/nzonal,nmerid,1/))
      NCERR(__LINE__)
      ncstat=nf90_put_var(ncid, meta(23)%varid, swrd, (/1,1,irec/),(/nzonal,nmerid,1/))
      NCERR(__LINE__)
      ncstat=nf90_put_var(ncid, meta(24)%varid, alb, (/1,1,irec/),(/nzonal,nmerid,1/))
      NCERR(__LINE__)
      ncstat=nf90_put_var(ncid, meta(25)%varid, psfc, (/1,1,irec/),(/nzonal,nmerid,1/))
      NCERR(__LINE__)

! optional variable
      if(meta(8)%iread==1) then
      ncstat=nf90_put_var(ncid, meta(8)%varid,cliq, (/1,1,1,irec/),(/nzonal,nmerid,nlev,1/))
      NCERR(__LINE__)
      end if
      if(meta(9)%iread==1) then
      ncstat=nf90_put_var(ncid, meta(9)%varid, cice, (/1,1,1,irec/),(/nzonal,nmerid,nlev,1/))
      NCERR(__LINE__)
      end if
      if(meta(10)%iread==1) then
      ncstat=nf90_put_var(ncid, meta(10)%varid,rain, (/1,1,1,irec/),(/nzonal,nmerid,nlev,1/))
      NCERR(__LINE__)
      end if
      if(meta(11)%iread==1) then
      ncstat=nf90_put_var(ncid, meta(11)%varid, clol, (/1,1,irec/),(/nzonal,nmerid,1/))
      NCERR(__LINE__)
      end if
      if(meta(12)%iread==1) then
      ncstat=nf90_put_var(ncid, meta(12)%varid, clom, (/1,1,irec/),(/nzonal,nmerid,1/))
      NCERR(__LINE__)
      end if
      if(meta(13)%iread==1) then
      ncstat=nf90_put_var(ncid, meta(13)%varid, cloh, (/1,1,irec/),(/nzonal,nmerid,1/))
      NCERR(__LINE__)
      end if
      if(meta(14)%iread==1) then
      ncstat=nf90_put_var(ncid, meta(14)%varid, u10m, (/1,1,irec/),(/nzonal,nmerid,1/))
      NCERR(__LINE__)
      end if
      if(meta(15)%iread==1) then
      ncstat=nf90_put_var(ncid, meta(15)%varid, v10m, (/1,1,irec/),(/nzonal,nmerid,1/))
      NCERR(__LINE__)
      end if
      if(meta(16)%iread==1) then
      ncstat=nf90_put_var(ncid, meta(16)%varid, usta, (/1,1,irec/),(/nzonal,nmerid,1/))
      NCERR(__LINE__)
      end if
      if(meta(17)%iread==1) then
      ncstat=nf90_put_var(ncid, meta(17)%varid, sshf, (/1,1,irec/),(/nzonal,nmerid,1/))
      NCERR(__LINE__)
      end if
      if(meta(18)%iread==1) then
      ncstat=nf90_put_var(ncid, meta(18)%varid, slhf, (/1,1,irec/),(/nzonal,nmerid,1/))
      NCERR(__LINE__)
      end if
      if(meta(19)%iread==1) then
      ncstat=nf90_put_var(ncid, meta(19)%varid, pblh, (/1,1,irec/),(/nzonal,nmerid,1/))
      NCERR(__LINE__)
      end if
      if(meta(20)%iread==1) then
      ncstat=nf90_put_var(ncid, meta(20)%varid, lspc, (/1,1,irec/),(/nzonal,nmerid,1/))
      NCERR(__LINE__)
      end if
      if(meta(21)%iread==1) then
      ncstat=nf90_put_var(ncid, meta(21)%varid, copc, (/1,1,irec/),(/nzonal,nmerid,1/)) 
      NCERR(__LINE__)
      end if
      if(meta(22)%iread==1) then
      ncstat=nf90_put_var(ncid, meta(22)%varid, soim, (/1,1,irec/),(/nzonal,nmerid,1/))
      NCERR(__LINE__)

      end if

   end subroutine write_data

!*****************************************************************************************
  subroutine get_infos
    implicit none

    ! local variables
    integer :: i,j,nlen
    integer :: iutsname,ipw,myuid,pxerr,pxlen
    logical :: ziend
    ! external functions
#if defined(PGI)
    integer,external :: getcwd
    integer,external :: hostnm
#endif


#ifdef IFORT
    ! Get user name
    call pxfgetuid(myuid,pxerr)
    call pxfstructcreate('passwd',ipw,pxerr)
    call pxfgetpwuid(myuid,ipw,pxerr)
    call pxfstrget(ipw,'pw_name',usrname,pxlen,pxerr)
    nlen=len(usrname)
    do i=1,nlen
       ziend=((ichar(usrname(i:i))<ichar('A')).or.(ichar(usrname(i:i))>ichar('z')))
       if (ziend) then
          do j=i,nlen
             usrname(j:j)=' '
          end do
          exit
       end if
    end do
    ! Get current directory
    call pxfgetcwd(cwd,pxlen,pxerr)
    ! Get host name
    call pxfstructcreate('utsname',iutsname,pxerr)
    call pxfuname(iutsname,pxerr)
    call pxfstrget(iutsname,'nodename',hname,pxlen,pxerr)
    ! Get time
    systime=ctime(time())

#elif defined(G95)

    ! Get user name
    call getlog(usrname)
    nlen=len(usrname)
    do i=1,nlen
       ziend=((ichar(usrname(i:i))<ichar('A')).or.(ichar(usrname(i:i))>ichar('z')))
       if (ziend) then
          do j=i,nlen
             usrname(j:j)=' '
          end do
          exit
       end if
    end do
    ! Get current directory
    status=getcwd(cwd)
    ! Get host name
    status=hostnm(hname)
    ! Get time
    systime=ctime(time())
    call fdate(systime)

#elif defined(PGI)

    ! Get user name
    call getenv('USER',usrname)
    nlen=len(usrname)
    do i=1,nlen
       ziend=((ichar(usrname(i:i))<ichar('A')).or.(ichar(usrname(i:i))>ichar('z')))
       if (ziend) then
          do j=i,nlen
             usrname(j:j)=' '
          end do
          exit
       end if
    end do
    ! Get current directory
    status=getcwd(cwd)
    ! Get host name
    status=hostnm(hname)
    ! Get time
    !systime=ctime(time())
    call fdate(systime)

#else
    usrname='unknown'
    hname='unknown'
    systime='unknown'
    cwd='unknown'
#endif

  end subroutine get_infos

!*****************************************************************************************
subroutine initvars

!  type :: varmeta
!     character(len=7)  :: mmvarname
!     integer           :: dim
!     character(len=5)  :: ncvarname
!     character(len=9)  :: unit
!     integer           :: iread    
!     integer           :: varid    ! returned by nf90_def_var
!     character(len=40) :: description
!  end type varmeta

meta(IALTI1)=varmeta('ALTI_3D', 3, 'alti', 'm'       , 1, 0, 'Altitude of half-sigma level'    )
meta(IPRES) =varmeta('PRES_3D', 3, 'pres', 'Pa'      , 1, 0, 'Pressure'                        )
meta(IWINZ) =varmeta('ZWIN_3D', 3, 'winz', 'm/s'     , 1, 0, 'Zonal wind'                      )
meta(IWINM) =varmeta('MWIN_3D', 3, 'winm', 'm/s'     , 1, 0, 'Meridional wind'                 )
meta(IRMIX) =varmeta('MIXR_3D', 3, 'sphu', 'kg/kg'   , 1, 0, 'Specific humidity'               )
meta(ITEMP) =varmeta('TEMP_3D', 3, 'temp', 'K'       , 1, 0, 'Temperature'                     )
meta(IT2M)  =varmeta('TEM2_2D', 2, 'tem2', 'K'       , 1, 0, '2m air temperature'              )
meta(ICLIQ) =varmeta('CLIQ_3D', 3, 'cliq', 'kg/kg'   , 1, 0, 'Cloud liquid water mixing ratio' )
meta(IRICE) =varmeta('CICE_3D', 3, 'cice', 'kg/kg'   , 1, 0, 'Ice mixing ratio'                )
meta(IRAIN) =varmeta('RAIN_3D', 3, 'rain', 'kg/kg'   , 1, 0, 'Rain water mixing ratio'         )
meta(ILCC)  =varmeta('LOWC_2D', 2, 'clol', 'fraction', 1, 0, 'Low cloud fraction '             )
meta(IMCC)  =varmeta('MEDC_2D', 2, 'clom', 'fraction', 1, 0, 'Medium cloud fraction '          )
meta(IHCC)  =varmeta('HIGC_2D', 2, 'cloh', 'fraction', 1, 0, 'High  cloud fraction '           )
meta(IU10M) =varmeta('U10M_2D', 2, 'u10m', 'm/s'     , 1, 0, '10 m U wind'                     )
meta(IV10M) =varmeta('V10M_2D', 2, 'v10m', 'm/s'     , 1, 0, '10 m V wind'                     )
meta(IUST)  =varmeta('USTA_2D', 2, 'usta', 'm/s'     , 1, 0, 'Frictional velocity'             )
meta(ISSH)  =varmeta('SSHF_2D', 2, 'sshf', 'W/m^2'   , 1, 0, 'Surface sensible heat flux'      )
meta(ISLH)  =varmeta('SLHF_2D', 2, 'slhf', 'W/m^2'   , 1, 0, 'Surface latent heat flux'        )
meta(IPBL)  =varmeta('PBLH_2D', 2, 'hght', 'm'       , 1, 0, 'PBL height from LM '             )
meta(ILSPC) =varmeta('TOPC_2D', 2, 'lspc', 'kg/m^2'  , 1, 0, 'Large scale precipitation'       )
meta(ICOPC) =varmeta('COPC_2D', 2, 'copc', 'kg/m^2'  , 1, 0, 'convective precipitation'        )
meta(ISOIM) =varmeta('SOIM_2D', 2, 'soim', 'm^3/m^3' , 1, 0, 'Soil Moisture level 1'           )
meta(ISWD)  =varmeta('SWRD_2D', 2, 'swrd', 'W/m^2'   , 1, 0, 'SW radiation down'               ) 
meta(IALB)  =varmeta('ALB_2D' , 2, 'alb' , 'fraction', 1, 0, 'albedo'                          ) 
meta(ISURP) =varmeta('SURP_2D', 2, 'psfc', 'Pa'      , 1, 0, 'Surface Pressure'               ) !!                          )
end subroutine initvars

END PROGRAM prepcosmomed

!===============================================================================

SUBROUTINE grib_read_3d(if,label,nx,ny,nz,idata,idlevs,field)
!--------------------------------------------------------------------------
! Legge da un file grib gia' aperto i valori relativi a un istante di un 
! campo 3D o 2D
!--------------------------------------------------------------------------
USE grib_api
USE datetime_class
USE grib2_utilities

IMPLICIT NONE

INTEGER, INTENT(IN) :: if,nx,ny,nz
CHARACTER (LEN=*), INTENT(IN) :: label
INTEGER, INTENT(OUT) :: idata,idlevs(nz)
REAL, INTENT(OUT) :: field(nx,ny,nz)
!
TYPE(datetime) :: vtime,vtime1,rtd,vtd1,vtd2
REAL :: values(nx*ny)
INTEGER :: ig,iret,kl,j
INTEGER :: nxg,nyg,lev(3)
CHARACTER (LEN=10) :: ch10,ch10b

!--------------------------------------------------------------------------

DO kl = 1,nz
  CALL grib_new_from_file(if,ig,iret)


! Controllo griglia
!  CALL grib_get(ig,"numberOfPointsAlongAParallel",nxg)
!  CALL grib_get(ig,"numberOfPointsAlongAMeridian",nyg)
if(kl==1)    write(6,*) 'leggo file3D ',label

CALL grib_get(ig,"Ni",nxg)
CALL grib_get(ig,"Nj",nyg)
  IF (nxg /= nx .OR. nyg /= ny) GOTO 9999 

! Leggo verification time
  CALL get_grib_time(ig, RTIME=rtd,VTIME=vtime, VTIME1=vtd1, VTIME2=vtd2,IRET=iret)
  IF (iret /= 0) GOTO 9997
  IF (kl == 1) THEN 
    CALL getval(vtime, SIMPLEDATE=ch10)
    READ (ch10,*) idata
    vtime1 = vtime
    write(6,*)'nz' ,nz, 'kl = ',kl,  " idata ", idata
  ELSE
    IF (vtime /= vtime1) GOTO 9998
  ENDIF

! Leggo l'id del livello
  CALL get_grib1_header(ig, LEV=lev, IRET=iret)
  IF (iret /= 0) GOTO 9996
  idlevs(kl) = lev(2)

! Leggo i valori
  CALL grib_get(ig,"values",values)
  DO j = 1,ny
    field(1:nx,j,kl) = values((j-1)*nx+1:j*nx)
  ENDDO
ENDDO
!!!!   write(6,*) 'label ',label,field(1,1,1),field(nx,ny,nz)

CALL grib_release(ig)
RETURN

!--------------------------------------------------------------------------

9999 CONTINUE
WRITE (*,*) "Trovato grib con griglia inattesa (nx,ny):"
WRITE (*,*) "File ",label,"  trovato: ",nxg,nyg,", atteso ",nx,ny
STOP 3

9998 CONTINUE
CALL getval(vtime, SIMPLEDATE=ch10b)
WRITE (*,*) "Trovato grib con data inattesa (vtime):"
WRITE (*,*) "File ",label," trovato: ",ch10b,", atteso ",ch10
STOP 3

9997 CONTINUE
WRITE (*,*) "Errore get_grib_time, file ",label
STOP 3

9996 CONTINUE
WRITE (*,*) "Errore get_grib1_header, file",label
STOP 3

END SUBROUTINE grib_read_3d

!===============================================================================

SUBROUTINE grib_read_2d(if,label,nx,ny,idata,idlev,field)
!--------------------------------------------------------------------------
! Legge da un file grib gia' aperto i valori relativi a un istante di un 
! campo 3D o 2D
!--------------------------------------------------------------------------
USE grib_api
USE datetime_class
USE grib2_utilities

IMPLICIT NONE

INTEGER, INTENT(IN) :: if,nx,ny
CHARACTER (LEN=*), INTENT(IN) :: label
INTEGER, INTENT(OUT) :: idata,idlev
REAL, INTENT(OUT) :: field(nx,ny)
!
TYPE(datetime) :: vtime,vtime1
REAL :: values(nx*ny)
INTEGER :: ig,iret,j
INTEGER :: nxg,nyg,lev(3)
CHARACTER (LEN=10) :: ch10

!--------------------------------------------------------------------------

CALL grib_new_from_file(if,ig,iret)

! Controllo griglia
!CALL grib_get(ig,"numberOfPointsAlongAParallel",nxg)
!CALL grib_get(ig,"numberOfPointsAlongAMeridian",nyg)
     write(6,*) 'leggo file2D ',label
CALL grib_get(ig,"Ni",nxg)
CALL grib_get(ig,"Nj",nyg)
IF (nxg /= nx .OR. nyg /= ny) GOTO 9999 

! Leggo verification time
CALL get_grib_time(ig, VTIME=vtime, IRET=iret)
IF (iret /= 0) GOTO 9997
CALL getval(vtime, SIMPLEDATE=ch10)
READ (ch10,*) idata
vtime1 = vtime

! Leggo l'id del livello
CALL get_grib1_header(ig, LEV=lev, IRET=iret)
IF (iret /= 0) GOTO 9996
idlev = lev(2)

! Leggo i valori
CALL grib_get(ig,"values",values)
DO j = 1,ny
  field(1:nx,j) = values((j-1)*nx+1:j*nx)
ENDDO
!!!!   write(6,*) 'label ',label,field(1,1),field(nx,ny)

RETURN

!--------------------------------------------------------------------------

9999 CONTINUE
WRITE (*,*) "Trovato grib con griglia inattesa (nx,ny):"
WRITE (*,*) "File ",label," trovato: ",nxg,nyg,", atteso ",nx,ny
STOP 3

9997 CONTINUE
WRITE (*,*) "Errore get_grib_time, file ",label
STOP 3

9996 CONTINUE
WRITE (*,*) "Errore get_grib1_header, file ",label
STOP 3

END SUBROUTINE grib_read_2d
